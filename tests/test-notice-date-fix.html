<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NoticeEditModal iOS æ—¥æœŸä¿®å¤æµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-section {
            background: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .warning { background: #fff3cd; color: #856404; }
        .code { 
            background: #f8f9fa; 
            padding: 5px 10px; 
            border-radius: 4px; 
            font-family: monospace; 
            margin: 5px 0;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #0056b3; }
    </style>
</head>
<body>
    <h1>ğŸ NoticeEditModal iOS æ—¥æœŸä¿®å¤æµ‹è¯•</h1>
    
    <div class="test-section">
        <h2>ğŸ“‹ æµ‹è¯•è¯´æ˜</h2>
        <p>è¿™ä¸ªæµ‹è¯•é¡µé¢æ¨¡æ‹Ÿ NoticeEditModal ç»„ä»¶ä¸­çš„æ—¶é—´ç»‘å®šåŠŸèƒ½ï¼ŒéªŒè¯åœ¨ iOS ç¯å¢ƒä¸‹çš„å…¼å®¹æ€§ã€‚</p>
        <p><strong>ä¸»è¦æµ‹è¯•åœºæ™¯ï¼š</strong></p>
        <ul>
            <li>formatDateForPicker æ–¹æ³•çš„ iOS å…¼å®¹æ€§</li>
            <li>æ—¥æœŸé€‰æ‹©å™¨ç»‘å®šåŠŸèƒ½</li>
            <li>æ—¶é—´éªŒè¯é€»è¾‘</li>
            <li>é”™è¯¯å¤„ç†æœºåˆ¶</li>
        </ul>
    </div>

    <div class="test-section">
        <h2>ğŸ”§ æ ¸å¿ƒåŠŸèƒ½æµ‹è¯•</h2>
        <button onclick="runFormatDateTests()">æµ‹è¯• formatDateForPicker</button>
        <button onclick="runDateValidationTests()">æµ‹è¯•æ—¥æœŸéªŒè¯</button>
        <button onclick="runPickerSimulation()">æ¨¡æ‹Ÿ Picker äº¤äº’</button>
        <div id="testResults"></div>
    </div>

    <div class="test-section">
        <h2>ğŸ“± Picker æ¨¡æ‹Ÿå™¨</h2>
        <div style="display: flex; gap: 20px; margin: 20px 0;">
            <div>
                <label>å¼€å§‹æ—¥æœŸ:</label><br>
                <input type="date" id="startDatePicker" onchange="onStartDateChange(event)">
                <div class="code">å€¼: <span id="startDateValue">æœªé€‰æ‹©</span></div>
            </div>
            <div>
                <label>ç»“æŸæ—¥æœŸ:</label><br>
                <input type="date" id="endDatePicker" onchange="onEndDateChange(event)">
                <div class="code">å€¼: <span id="endDateValue">æœªé€‰æ‹©</span></div>
            </div>
        </div>
        <div id="pickerResults"></div>
    </div>

    <script>
        // æ¨¡æ‹Ÿ IOSDateFix å·¥å…·ç±»
        class IOSDateFix {
            static isIncompatibleFormat(dateString) {
                if (!dateString || typeof dateString !== 'string') return false;
                const patterns = [
                    /(\d{1,2})\/(\d{1,2})\/(\d{4}),?\s*(\d{1,2}):(\d{1,2}):(\d{1,2})\s*(AM|PM)/i,
                    /(\d{1,2})\/(\d{1,2})\/(\d{4}),?\s*(\d{1,2}):(\d{1,2})\s*(AM|PM)/i,
                    /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/,
                ];
                return patterns.some(pattern => pattern.test(dateString.trim()));
            }

            static convertToCompatibleFormat(dateString) {
                if (!dateString || typeof dateString !== 'string') return dateString;
                let cleanString = dateString.trim();

                // å¤„ç† "9/13/2025, 5:39:15 PM" æ ¼å¼
                const ampmMatch = cleanString.match(/(\d{1,2})\/(\d{1,2})\/(\d{4}),?\s*(\d{1,2}):(\d{1,2}):(\d{1,2})\s*(AM|PM)/i);
                if (ampmMatch) {
                    let [, month, day, year, hour, minute, second, ampm] = ampmMatch;
                    let hour24 = parseInt(hour);
                    if (ampm.toUpperCase() === 'PM' && hour24 !== 12) hour24 += 12;
                    if (ampm.toUpperCase() === 'AM' && hour24 === 12) hour24 = 0;
                    return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}T${hour24.toString().padStart(2, '0')}:${minute.padStart(2, '0')}:${second.padStart(2, '0')}`;
                }

                // å¤„ç† "9/13/2025" æ ¼å¼
                const dateMatch = cleanString.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
                if (dateMatch) {
                    const [, month, day, year] = dateMatch;
                    return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
                }

                return dateString;
            }

            static safeCreateDate(input) {
                if (input instanceof Date) {
                    return isNaN(input.getTime()) ? null : input;
                }
                if (typeof input === 'number') {
                    const date = new Date(input);
                    return isNaN(date.getTime()) ? null : date;
                }
                if (typeof input === 'string') {
                    try {
                        if (this.isIncompatibleFormat(input)) {
                            const compatibleFormat = this.convertToCompatibleFormat(input);
                            const date = new Date(compatibleFormat);
                            return isNaN(date.getTime()) ? null : date;
                        }
                        const date = new Date(input);
                        return isNaN(date.getTime()) ? null : date;
                    } catch (error) {
                        console.error('åˆ›å»ºDateå¯¹è±¡å¤±è´¥:', error);
                        return null;
                    }
                }
                return null;
            }
        }

        // æ¨¡æ‹Ÿ TimeUtils
        class TimeUtils {
            static formatDate(date, format) {
                if (!date) return '';
                if (format === 'YYYY-MM-DD') {
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    return `${year}-${month}-${day}`;
                }
                return date.toISOString();
            }
        }

        // æ¨¡æ‹Ÿè¡¨å•æ•°æ®
        let formData = {
            startDate: '',
            endDate: ''
        };

        // ä¿®å¤åçš„ formatDateForPicker æ–¹æ³•
        function formatDateForPicker(dateTime) {
            if (!dateTime) return '';
            
            try {
                // ğŸ ä½¿ç”¨iOSå…¼å®¹çš„å®‰å…¨æ—¥æœŸåˆ›å»º
                const date = IOSDateFix.safeCreateDate(dateTime);
                if (!date || isNaN(date.getTime())) {
                    console.warn('âš ï¸ æ— æ•ˆçš„æ—¥æœŸæ—¶é—´:', dateTime);
                    return '';
                }
                
                // ğŸ¯ ä½¿ç”¨å®‰å…¨çš„æ ¼å¼åŒ–æ–¹æ³•
                return TimeUtils.formatDate(date, 'YYYY-MM-DD');
            } catch (error) {
                console.error('âŒ formatDateForPicker å¤±è´¥:', error, 'è¾“å…¥:', dateTime);
                return '';
            }
        }

        // ä¿®å¤åçš„æ—¥æœŸå˜åŒ–å¤„ç†
        function onStartDateChange(e) {
            try {
                const dateValue = e.target ? e.target.value : e.detail.value;
                console.log('ğŸ“… å¼€å§‹æ—¥æœŸå˜æ›´:', dateValue);
                
                if (dateValue && /^\d{4}-\d{2}-\d{2}$/.test(dateValue)) {
                    formData.startDate = dateValue;
                    document.getElementById('startDateValue').textContent = dateValue;
                    updateResults('å¼€å§‹æ—¥æœŸæ›´æ–°æˆåŠŸ: ' + dateValue, 'success');
                } else {
                    console.warn('âš ï¸ å¼€å§‹æ—¥æœŸæ ¼å¼å¼‚å¸¸:', dateValue);
                    formData.startDate = '';
                    updateResults('å¼€å§‹æ—¥æœŸæ ¼å¼å¼‚å¸¸: ' + dateValue, 'warning');
                }
            } catch (error) {
                console.error('âŒ å¼€å§‹æ—¥æœŸå¤„ç†å¤±è´¥:', error);
                formData.startDate = '';
                updateResults('å¼€å§‹æ—¥æœŸå¤„ç†å¤±è´¥: ' + error.message, 'error');
            }
        }

        function onEndDateChange(e) {
            try {
                const dateValue = e.target ? e.target.value : e.detail.value;
                console.log('ğŸ“… ç»“æŸæ—¥æœŸå˜æ›´:', dateValue);
                
                if (dateValue && /^\d{4}-\d{2}-\d{2}$/.test(dateValue)) {
                    formData.endDate = dateValue;
                    document.getElementById('endDateValue').textContent = dateValue;
                    updateResults('ç»“æŸæ—¥æœŸæ›´æ–°æˆåŠŸ: ' + dateValue, 'success');
                } else {
                    console.warn('âš ï¸ ç»“æŸæ—¥æœŸæ ¼å¼å¼‚å¸¸:', dateValue);
                    formData.endDate = '';
                    updateResults('ç»“æŸæ—¥æœŸæ ¼å¼å¼‚å¸¸: ' + dateValue, 'warning');
                }
            } catch (error) {
                console.error('âŒ ç»“æŸæ—¥æœŸå¤„ç†å¤±è´¥:', error);
                formData.endDate = '';
                updateResults('ç»“æŸæ—¥æœŸå¤„ç†å¤±è´¥: ' + error.message, 'error');
            }
        }

        // æµ‹è¯•å‡½æ•°
        function runFormatDateTests() {
            const testCases = [
                "9/13/2025, 5:39:15 PM",
                "2025-09-13T17:39:15.000Z",
                "2025-09-13",
                "9/13/2025",
                "invalid-date",
                "",
                null
            ];

            let results = '<h3>ğŸ“Š formatDateForPicker æµ‹è¯•ç»“æœ</h3>';
            
            testCases.forEach((testCase, index) => {
                try {
                    const result = formatDateForPicker(testCase);
                    const status = result ? 'success' : 'warning';
                    results += `<div class="test-result ${status}">
                        <strong>æµ‹è¯• ${index + 1}:</strong> 
                        <div class="code">è¾“å…¥: ${JSON.stringify(testCase)}</div>
                        <div class="code">è¾“å‡º: ${JSON.stringify(result)}</div>
                    </div>`;
                } catch (error) {
                    results += `<div class="test-result error">
                        <strong>æµ‹è¯• ${index + 1} å¤±è´¥:</strong> 
                        <div class="code">è¾“å…¥: ${JSON.stringify(testCase)}</div>
                        <div class="code">é”™è¯¯: ${error.message}</div>
                    </div>`;
                }
            });

            document.getElementById('testResults').innerHTML = results;
        }

        function runDateValidationTests() {
            const testCases = [
                { start: '2025-01-01', end: '2025-01-02', expected: true },
                { start: '2025-01-02', end: '2025-01-01', expected: false },
                { start: '2025-01-01', end: '2025-01-01', expected: true },
                { start: '2025-01-01', end: '', expected: true },
                { start: '', end: '2025-01-01', expected: true },
                { start: '', end: '', expected: false }
            ];

            let results = '<h3>ğŸ” æ—¥æœŸéªŒè¯æµ‹è¯•ç»“æœ</h3>';
            
            testCases.forEach((testCase, index) => {
                const originalStart = formData.startDate;
                const originalEnd = formData.endDate;
                
                formData.startDate = testCase.start;
                formData.endDate = testCase.end;
                
                const result = isTimeRangeValid();
                const status = result === testCase.expected ? 'success' : 'error';
                
                results += `<div class="test-result ${status}">
                    <strong>æµ‹è¯• ${index + 1}:</strong> 
                    <div class="code">å¼€å§‹: ${testCase.start || 'ç©º'} â†’ ç»“æŸ: ${testCase.end || 'ç©º'}</div>
                    <div class="code">æœŸæœ›: ${testCase.expected}, å®é™…: ${result}</div>
                </div>`;
                
                // æ¢å¤åŸå§‹å€¼
                formData.startDate = originalStart;
                formData.endDate = originalEnd;
            });

            document.getElementById('testResults').innerHTML = results;
        }

        function runPickerSimulation() {
            let results = '<h3>ğŸ–±ï¸ Picker äº¤äº’æ¨¡æ‹Ÿ</h3>';
            results += `<div class="test-result success">
                <p>è¯·ä½¿ç”¨ä¸Šæ–¹çš„æ—¥æœŸé€‰æ‹©å™¨è¿›è¡Œäº¤äº’æµ‹è¯•ã€‚é€‰æ‹©æ—¥æœŸåï¼Œä¼šè‡ªåŠ¨è°ƒç”¨ä¿®å¤åçš„æ—¥æœŸå¤„ç†æ–¹æ³•ã€‚</p>
                <div class="code">å½“å‰å¼€å§‹æ—¥æœŸ: ${formData.startDate || 'æœªè®¾ç½®'}</div>
                <div class="code">å½“å‰ç»“æŸæ—¥æœŸ: ${formData.endDate || 'æœªè®¾ç½®'}</div>
                <div class="code">æ—¶é—´èŒƒå›´æœ‰æ•ˆæ€§: ${isTimeRangeValid()}</div>
            </div>`;
            document.getElementById('testResults').innerHTML = results;
        }

        function isTimeRangeValid() {
            // éæ°¸ä¹…å…¬å‘Šå¿…é¡»è‡³å°‘å¡«å†™ä¸€ä¸ªæ—¥æœŸ
            if (!formData.startDate && !formData.endDate) {
                return false;
            }
            
            // å¦‚æœåŒæ—¶å¡«å†™äº†å¼€å§‹å’Œç»“æŸæ—¥æœŸï¼Œéœ€è¦éªŒè¯é¡ºåº
            if (formData.startDate && formData.endDate) {
                try {
                    const startDate = IOSDateFix.safeCreateDate(formData.startDate);
                    const endDate = IOSDateFix.safeCreateDate(formData.endDate);
                    
                    if (startDate && endDate) {
                        return startDate <= endDate;
                    }
                    
                    return formData.startDate <= formData.endDate;
                } catch (error) {
                    return formData.startDate <= formData.endDate;
                }
            }
            
            return true;
        }

        function updateResults(message, type) {
            const resultsDiv = document.getElementById('pickerResults');
            const timestamp = new Date().toLocaleTimeString();
            resultsDiv.innerHTML += `<div class="test-result ${type}">
                [${timestamp}] ${message}
            </div>`;
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }

        // é¡µé¢åŠ è½½å®Œæˆåè¿è¡ŒåŸºç¡€æµ‹è¯•
        window.onload = function() {
            updateResults('ğŸ NoticeEditModal iOS æ—¥æœŸä¿®å¤æµ‹è¯•ç¯å¢ƒå·²å°±ç»ª', 'success');
            updateResults('è¯·ç‚¹å‡»æµ‹è¯•æŒ‰é’®æˆ–ä½¿ç”¨æ—¥æœŸé€‰æ‹©å™¨è¿›è¡Œäº¤äº’æµ‹è¯•', 'success');
        };
    </script>
</body>
</html>
