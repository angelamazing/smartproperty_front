# 统一时间处理方案及前端对接文档

## 一、概述

为解决系统中时间处理不一致、时区混乱等问题，特制定本统一时间处理方案。本方案旨在规范前后端的时间处理逻辑，确保时间数据在存储、传输和展示过程中的一致性和准确性。

## 二、总体原则

1. **存储使用UTC时间**：所有时间数据在数据库中统一存储为UTC时间
2. **传输使用ISO 8601格式**：接口交互时使用ISO 8601标准格式
3. **显示使用北京时间**：所有用户界面显示的时间统一转换为北京时间(UTC+8)
4. **统一工具类**：前后端分别提供统一的时间处理工具类
5. **明确的时区处理**：所有时间操作都必须明确指定时区

## 三、后端时间处理规范

### 3.1 核心原则

- 服务器统一使用UTC时间进行存储和计算
- 所有需要显示给用户的时间，在返回给前端前统一转换为UTC时间（前端负责转换为北京时间显示）
- 所有从前端接收的时间数据，先转换为UTC时间再进行存储和处理

### 3.2 使用工具

后端统一使用 `moment-timezone` 库处理时间，禁止直接使用原生 Date 对象或不带时区的 moment。

### 3.3 时间处理工具类

使用已有的 `utils/timeUtils.js` 作为统一的时间处理工具类，所有时间相关操作都应通过该工具类完成。

**核心方法**：

```javascript
// 获取当前北京时间
static getBeijingTime() {}

// 将北京时间转换为UTC时间用于存储
static toUTCForStorage(beijingTime) {}

// 将UTC时间转换为北京时间用于显示
static toBeijingForDisplay(utcTime) {}

// 将UTC时间转换为北京时间（仅日期部分）
static toBeijingDateOnly(utcTime) {}

// 将UTC时间转换为北京时间（仅时间部分）
static toBeijingTimeOnly(utcTime) {}

// 格式化时间为友好的显示格式
static formatTime(time, format = 'YYYY-MM-DD HH:mm:ss') {}
```

### 3.4 数据库操作规范

- 所有日期时间字段统一使用 `DATETIME` 或 `TIMESTAMP` 类型
- 插入或更新时间字段时，必须使用 `TimeUtils.toUTCForStorage()` 方法转换为UTC时间
- 查询时间字段时，不需要特殊处理，由前端负责转换显示

### 3.5 常见场景处理

#### 3.5.1 记录创建/更新时间
```javascript
const now = new Date(); // 服务器当前时间（UTC）

// 插入记录示例
await connection.execute(
  `INSERT INTO table_name (..., createTime, updateTime) VALUES (..., ?, ?)`,
  [..., now, now]
);
```

#### 3.5.2 处理前端提交的时间
```javascript
// 从前端接收的北京时间字符串
const beijingTimeStr = req.body.eventTime; // 例如：'2024-01-15 18:30:00'

// 转换为UTC时间存储
const utcTime = TimeUtils.toUTCForStorage(beijingTimeStr);

// 存储到数据库
await connection.execute(
  `UPDATE table_name SET eventTime = ? WHERE id = ?`,
  [utcTime, req.params.id]
);
```

#### 3.5.3 返回时间数据给前端
```javascript
// 从数据库查询的UTC时间
const order = await connection.execute(
  `SELECT * FROM dining_orders WHERE id = ?`,
  [req.params.id]
);

// 不需要特殊转换，直接返回UTC时间，前端负责转换显示
res.json({
  success: true,
  data: order
});
```

## 四、前端时间处理规范

### 4.1 核心原则

- 所有从后端接收的时间数据，统一视为UTC时间
- 所有显示给用户的时间，统一转换为北京时间
- 所有提交给后端的时间数据，统一转换为ISO 8601格式的UTC时间

### 4.2 使用工具

推荐使用 `day.js` 库处理时间，轻量且功能强大。也可以使用原生JavaScript的Date对象，但需要特别注意时区处理。

### 4.3 时间处理工具类

创建统一的时间处理工具类 `TimeUtils`，封装所有时间处理逻辑。

#### 4.3.1 使用day.js的实现

```javascript
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';
import 'dayjs/locale/zh-cn';

// 配置插件
dayjs.extend(relativeTime);
dayjs.locale('zh-cn');

export class TimeUtils {
  /**
   * 解析后端时间字符串为dayjs对象
   * @param {string} timeString - 后端UTC时间字符串
   * @returns {dayjs} dayjs对象
   */
  static parseTime(timeString) {
    if (!timeString) return null;
    return dayjs(timeString);
  }

  /**
   * 格式化UTC时间为北京时间字符串
   * @param {string|Date} time - UTC时间字符串或Date对象
   * @param {string} format - 格式类型
   * @returns {string} 格式化后的北京时间字符串
   */
  static formatTime(time, format = 'YYYY-MM-DD HH:mm:ss') {
    if (!time) return '';
    // 将UTC时间转换为北京时间显示
    return dayjs(time).utcOffset(8).format(format);
  }

  /**
   * 获取相对时间（如：3分钟前、2小时前）
   * @param {string|Date} time - UTC时间字符串或Date对象
   * @returns {string} 相对时间字符串
   */
  static getRelativeTime(time) {
    if (!time) return '';
    return dayjs(time).fromNow();
  }

  /**
   * 将北京时间转换为UTC时间用于提交给后端
   * @param {string|Date} beijingTime - 北京时间
   * @returns {string} ISO 8601格式的UTC时间字符串
   */
  static toUTCForSubmit(beijingTime) {
    if (!beijingTime) return '';
    return dayjs(beijingTime).utcOffset(8).utc().toISOString();
  }

  /**
   * 获取当前日期字符串（YYYY-MM-DD格式）
   * @returns {string} 当前日期
   */
  static getCurrentDate() {
    return dayjs().utcOffset(8).format('YYYY-MM-DD');
  }

  /**
   * 获取当前时间字符串（HH:mm格式）
   * @returns {string} 当前时间
   */
  static getCurrentTime() {
    return dayjs().utcOffset(8).format('HH:mm');
  }

  /**
   * 验证时间格式是否有效
   * @param {string} timeString - 时间字符串
   * @returns {boolean} 是否有效
   */
  static isValidTime(timeString) {
    if (!timeString) return false;
    return dayjs(timeString).isValid();
  }
}
```

### 4.4 组件中的使用规范

#### 4.4.1 Vue组件中的使用

**Vue 2 全局过滤器**
```javascript
// main.js
import Vue from 'vue';
import { TimeUtils } from '@/utils/TimeUtils';

Vue.filter('formatTime', function(time, format = 'YYYY-MM-DD HH:mm') {
  return TimeUtils.formatTime(time, format);
});

Vue.filter('relativeTime', function(time) {
  return TimeUtils.getRelativeTime(time);
});
```

**在模板中使用**
```vue
<template>
  <div>
    <!-- 格式化时间 -->
    <p>创建时间: {{ item.createTime | formatTime('YYYY-MM-DD HH:mm') }}</p>
    
    <!-- 相对时间 -->
    <p>更新时间: {{ item.updateTime | relativeTime }}</p>
  </div>
</template>
```

**Vue 3 Composition API**
```vue
<template>
  <div>
    <p>创建时间: {{ formatTime(item.createTime, 'YYYY-MM-DD HH:mm') }}</p>
    <p>更新时间: {{ getRelativeTime(item.updateTime) }}</p>
  </div>
</template>

<script setup>
import { TimeUtils } from '@/utils/TimeUtils';

const props = defineProps(['item']);

const formatTime = (time, format) => {
  return TimeUtils.formatTime(time, format);
};

const getRelativeTime = (time) => {
  return TimeUtils.getRelativeTime(time);
};
</script>
```

#### 4.4.2 React组件中的使用

**自定义Hook**
```javascript
// hooks/useTime.js
import { useMemo } from 'react';
import { TimeUtils } from '@/utils/TimeUtils';

export const useTime = () => {
  const formatTime = useMemo(() => {
    return (time, format) => TimeUtils.formatTime(time, format);
  }, []);

  const getRelativeTime = useMemo(() => {
    return (time) => TimeUtils.getRelativeTime(time);
  }, []);

  return {
    formatTime,
    getRelativeTime,
    getCurrentDate: TimeUtils.getCurrentDate,
    getCurrentTime: TimeUtils.getCurrentTime,
    toUTCForSubmit: TimeUtils.toUTCForSubmit
  };
};
```

**在组件中使用**
```jsx
import React from 'react';
import { useTime } from '@/hooks/useTime';

const TimeDisplay = ({ item }) => {
  const { formatTime, getRelativeTime } = useTime();

  return (
    <div>
      <p>创建时间: {formatTime(item.createTime, 'YYYY-MM-DD HH:mm')}</p>
      <p>更新时间: {getRelativeTime(item.updateTime)}</p>
    </div>
  );
};

export default TimeDisplay;
```

### 4.5 表单提交规范

**日期选择器**
```vue
<template>
  <el-form @submit="handleSubmit">
    <el-form-item label="日期">
      <el-date-picker
        v-model="form.date"
        type="date"
        placeholder="选择日期"
        format="YYYY-MM-DD"
        value-format="YYYY-MM-DD"
      />
    </el-form-item>
    
    <el-form-item label="时间">
      <el-time-picker
        v-model="form.time"
        placeholder="选择时间"
        format="HH:mm"
        value-format="HH:mm"
      />
    </el-form-item>
    
    <el-button type="primary" @click="handleSubmit">提交</el-button>
  </el-form>
</template>

<script setup>
import { ref } from 'vue';
import { TimeUtils } from '@/utils/TimeUtils';

const form = ref({
  date: TimeUtils.getCurrentDate(),
  time: TimeUtils.getCurrentTime()
});

const handleSubmit = () => {
  // 组合日期和时间
  const localDateTime = `${form.value.date} ${form.value.time}`;
  
  // 转换为UTC时间提交给后端
  const utcDateTime = TimeUtils.toUTCForSubmit(localDateTime);
  
  // 提交数据
  api.submitData({
    eventTime: utcDateTime
  }).then(response => {
    // 处理响应
  });
};
</script>
```

**时间范围选择**
```vue
<template>
  <el-form>
    <el-form-item label="时间范围">
      <el-date-picker
        v-model="form.dateRange"
        type="datetimerange"
        range-separator="至"
        start-placeholder="开始时间"
        end-placeholder="结束时间"
        format="YYYY-MM-DD HH:mm"
        value-format="YYYY-MM-DDTHH:mm:ss.sssZ"
      />
    </el-form-item>
  </el-form>
</template>
```

### 4.6 表格显示规范

**Vue表格组件**
```vue
<template>
  <el-table :data="tableData">
    <el-table-column prop="createTime" label="创建时间">
      <template #default="{ row }">
        {{ formatTime(row.createTime, 'YYYY-MM-DD HH:mm') }}
      </template>
    </el-table-column>
    
    <el-table-column prop="updateTime" label="更新时间">
      <template #default="{ row }">
        <span :title="formatTime(row.updateTime, 'YYYY-MM-DD HH:mm:ss')">
          {{ getRelativeTime(row.updateTime) }}
        </span>
      </template>
    </el-table-column>
  </el-table>
</template>

<script setup>
import { TimeUtils } from '@/utils/TimeUtils';

const formatTime = (time, format) => TimeUtils.formatTime(time, format);
const getRelativeTime = (time) => TimeUtils.getRelativeTime(time);
</script>
```

## 五、接口交互约定

### 5.1 后端返回时间格式

后端所有API返回的时间字段统一使用ISO 8601标准格式的UTC时间：

```json
{
  "createTime": "2024-01-15T10:30:00.000Z",
  "updateTime": "2024-01-15T14:25:30.500Z"
}
```

### 5.2 前端提交时间格式

前端提交给后端的时间字段必须转换为ISO 8601标准格式的UTC时间：

```json
{
  "eventTime": "2024-01-15T10:30:00.000Z",
  "deadline": "2024-01-20T18:00:00.000Z"
}
```

### 5.3 特殊场景约定

#### 5.3.1 仅日期字段

对于只需要日期的字段，使用 `YYYY-MM-DD` 格式：

```json
{
  "date": "2024-01-15",
  "joinDate": "2024-01-01"
}
```

#### 5.3.2 仅时间字段

对于只需要时间的字段，使用 `HH:mm` 格式：

```json
{
  "startTime": "14:00",
  "endTime": "16:00"
}
```

## 六、常见业务场景处理

### 6.1 报餐时间处理

**功能说明**：用户在规定时间内进行报餐操作

**处理逻辑**：
1. 前端获取当前北京时间，判断是否在允许的报餐时间范围内
2. 如果在范围内，将用户选择的日期和餐次信息提交给后端
3. 后端验证时间有效性，存储相关信息

**代码示例**：
```javascript
// 检查是否可以报餐
const canOrderMeal = (mealType) => {
  const now = dayjs().utcOffset(8);
  const today = now.format('YYYY-MM-DD');
  
  // 定义各餐次的截止时间
  const deadlines = {
    'breakfast': `${today}T08:00:00`, // 早餐8点前
    'lunch': `${today}T11:00:00`,     // 午餐11点前
    'dinner': `${today}T17:00:00`     // 晚餐17点前
  };
  
  const deadline = dayjs(deadlines[mealType]).utcOffset(8);
  return now.isBefore(deadline);
};
```

### 6.2 预约时间处理

**功能说明**：用户可以预约未来的时间段

**处理逻辑**：
1. 前端验证预约时间必须是未来时间
2. 验证开始时间和结束时间的合理性
3. 将UTC时间提交给后端存储

**代码示例**：
```javascript
// 预约时间验证
const validateReservationTime = (date, startTime, endTime) => {
  const now = dayjs().utcOffset(8);
  const reservationDate = dayjs(`${date}T${startTime}:00`).utcOffset(8);
  
  // 检查是否在未来
  if (reservationDate.isBefore(now)) {
    return { valid: false, message: '预约时间必须是未来时间' };
  }
  
  // 检查时间范围
  const start = dayjs(`2000-01-01T${startTime}:00`).utcOffset(8);
  const end = dayjs(`2000-01-01T${endTime}:00`).utcOffset(8);
  const duration = end.diff(start, 'minute');
  
  if (duration <= 0) {
    return { valid: false, message: '结束时间必须晚于开始时间' };
  }
  
  return { valid: true };
};
```

## 七、性能优化与错误处理

### 7.1 时间格式化缓存

对于大量数据（如表格列表）的时间格式化，建议使用缓存机制避免重复计算：

```javascript
export class TimeCache {
  static cache = new Map();
  
  static format(time, format) {
    const key = `${time}_${format}`;
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    
    const formatted = TimeUtils.formatTime(time, format);
    this.cache.set(key, formatted);
    return formatted;
  }
  
  static clear() {
    this.cache.clear();
  }
}
```

### 7.2 延迟格式化

在大列表或虚拟滚动场景中，可以使用延迟格式化避免阻塞渲染：

```javascript
// React示例
const TimeCell = ({ time, format }) => {
  const [formattedTime, setFormattedTime] = useState('');
  
  useEffect(() => {
    // 延迟格式化，避免阻塞渲染
    const timer = setTimeout(() => {
      setFormattedTime(TimeUtils.formatTime(time, format));
    }, 0);
    
    return () => clearTimeout(timer);
  }, [time, format]);
  
  return <span>{formattedTime}</span>;
};
```

### 7.3 安全格式化

添加错误处理，确保时间格式化失败时不会导致应用崩溃：

```javascript
// 安全的时间格式化
const safeFormatTime = (time, format = 'YYYY-MM-DD HH:mm:ss') => {
  try {
    if (!time) return '--';
    if (!TimeUtils.isValidTime(time)) return '无效时间';
    return TimeUtils.formatTime(time, format);
  } catch (error) {
    console.error('时间格式化错误:', error);
    return '--';
  }
};
```

## 八、总结

本统一时间处理方案通过明确的规范和统一的工具类，解决了系统中时间处理不一致的问题。前端开发人员应严格按照本文档的规范进行时间处理，确保时间数据在整个系统中的一致性和准确性。

**关键要点**：
1. 后端存储UTC时间，前端显示北京时间
2. 接口交互使用ISO 8601格式
3. 使用统一的时间处理工具类
4. 针对不同场景采用合适的处理方式
5. 注意性能优化和错误处理

通过遵循这些规范，可以有效避免时间相关的bug，提升用户体验和开发效率。