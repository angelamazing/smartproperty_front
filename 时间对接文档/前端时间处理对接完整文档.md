# 前端时间处理对接完整文档

## 📋 文档概述

本文档为前端开发人员提供完整的时间处理对接指南，包含统一时间处理方案、工具类使用、组件示例和最佳实践。

## 🎯 核心原则

### 时间处理规范
1. **后端返回**：所有时间字段都是UTC时间（ISO 8601格式）
2. **前端显示**：统一转换为北京时间显示
3. **前端提交**：将北京时间转换为UTC时间提交给后端
4. **工具类**：使用统一的时间处理工具类，禁止直接使用原生Date对象

### 时间格式约定
- **API返回格式**：`2024-01-15T10:30:00.000Z`（UTC时间）
- **前端显示格式**：`2024-01-15 18:30:00`（北京时间）
- **前端提交格式**：`2024-01-15T10:30:00.000Z`（UTC时间）

## 🛠️ 环境配置

### 1. 安装依赖

```bash
npm install dayjs
```

### 2. 创建时间处理工具类

创建文件 `src/utils/TimeUtils.js`：

```javascript
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';
import 'dayjs/locale/zh-cn';

// 配置插件
dayjs.extend(relativeTime);
dayjs.locale('zh-cn');

/**
 * 前端时间处理工具类
 * 统一处理从后端接收的UTC时间，并转换为北京时间显示
 */
export class TimeUtils {
  /**
   * 解析后端时间字符串为dayjs对象
   * @param {string} timeString - 后端UTC时间字符串
   * @returns {dayjs|null} dayjs对象，如果输入无效则返回null
   */
  static parseTime(timeString) {
    if (!timeString) return null;
    return dayjs(timeString);
  }

  /**
   * 格式化UTC时间为北京时间字符串
   * @param {string|Date} time - UTC时间字符串或Date对象
   * @param {string} format - 格式类型
   * @returns {string} 格式化后的北京时间字符串
   */
  static formatTime(time, format = 'YYYY-MM-DD HH:mm:ss') {
    if (!time) return '';
    // 将UTC时间转换为北京时间显示
    return dayjs(time).utcOffset(8).format(format);
  }

  /**
   * 获取相对时间（如：3分钟前、2小时前）
   * @param {string|Date} time - UTC时间字符串或Date对象
   * @returns {string} 相对时间字符串
   */
  static getRelativeTime(time) {
    if (!time) return '';
    return dayjs(time).fromNow();
  }

  /**
   * 将北京时间转换为UTC时间用于提交给后端
   * @param {string|Date} beijingTime - 北京时间
   * @returns {string} ISO 8601格式的UTC时间字符串
   */
  static toUTCForSubmit(beijingTime) {
    if (!beijingTime) return '';
    // 判断输入是否为日期时间字符串
    if (typeof beijingTime === 'string') {
      // 尝试解析不同格式的日期时间
      let parsed;
      if (beijingTime.includes('T')) {
        // ISO格式字符串
        parsed = dayjs(beijingTime);
      } else if (beijingTime.includes(' ')) {
        // YYYY-MM-DD HH:mm:ss格式
        parsed = dayjs(beijingTime, 'YYYY-MM-DD HH:mm:ss');
      } else if (beijingTime.length === 10) {
        // YYYY-MM-DD格式
        parsed = dayjs(beijingTime, 'YYYY-MM-DD');
      } else {
        // 其他格式，尝试自动解析
        parsed = dayjs(beijingTime);
      }
      
      if (parsed.isValid()) {
        // 转换为UTC时间
        return parsed.utc().toISOString();
      }
      return '';
    }
    
    // 如果是Date对象，直接转换
    return dayjs(beijingTime).utc().toISOString();
  }

  /**
   * 获取当前日期字符串（YYYY-MM-DD格式）
   * @returns {string} 当前日期
   */
  static getCurrentDate() {
    return dayjs().utcOffset(8).format('YYYY-MM-DD');
  }

  /**
   * 获取当前时间字符串（HH:mm格式）
   * @returns {string} 当前时间
   */
  static getCurrentTime() {
    return dayjs().utcOffset(8).format('HH:mm');
  }

  /**
   * 验证时间格式是否有效
   * @param {string} timeString - 时间字符串
   * @returns {boolean} 是否有效
   */
  static isValidTime(timeString) {
    if (!timeString) return false;
    return dayjs(timeString).isValid();
  }

  /**
   * 计算两个时间之间的差值（分钟）
   * @param {string|Date} startTime - 开始时间
   * @param {string|Date} endTime - 结束时间
   * @returns {number} 时间差（分钟）
   */
  static getTimeDiff(startTime, endTime) {
    const start = this.parseTime(startTime);
    const end = this.parseTime(endTime);
    
    if (!start || !end) return 0;
    
    return end.diff(start, 'minute');
  }

  /**
   * 检查日期是否为今天
   * @param {string|Date} date - 日期
   * @returns {boolean} 是否为今天
   */
  static isToday(date) {
    if (!date) return false;
    const targetDate = this.parseTime(date);
    const today = dayjs().utcOffset(8);
    
    return targetDate && targetDate.isSame(today, 'day');
  }

  /**
   * 检查日期是否为过去
   * @param {string|Date} date - 日期
   * @returns {boolean} 是否为过去
   */
  static isPastDate(date) {
    if (!date) return false;
    const targetDate = this.parseTime(date);
    const today = dayjs().utcOffset(8).startOf('day');
    
    return targetDate && targetDate.isBefore(today);
  }

  /**
   * 检查日期是否为未来
   * @param {string|Date} date - 日期
   * @returns {boolean} 是否为未来
   */
  static isFutureDate(date) {
    if (!date) return false;
    const targetDate = this.parseTime(date);
    const today = dayjs().utcOffset(8).endOf('day');
    
    return targetDate && targetDate.isAfter(today);
  }

  /**
   * 安全的时间格式化，包含错误处理
   * @param {string|Date} time - 时间
   * @param {string} format - 格式
   * @returns {string} 格式化后的时间字符串或占位符
   */
  static safeFormatTime(time, format = 'YYYY-MM-DD HH:mm:ss') {
    try {
      if (!time) return '--';
      if (!this.isValidTime(time)) return '无效时间';
      return this.formatTime(time, format);
    } catch (error) {
      console.error('时间格式化错误:', error);
      return '--';
    }
  }

  /**
   * 处理不同时区的时间显示
   * @param {string|Date} time - 时间
   * @param {string} timezone - 时区，默认Asia/Shanghai
   * @param {string} format - 格式
   * @returns {string} 格式化后的时间字符串
   */
  static formatTimeWithTimezone(time, timezone = 'Asia/Shanghai', format = 'YYYY-MM-DD HH:mm:ss') {
    try {
      if (!time) return '--';
      
      // 使用Intl.DateTimeFormat处理时区转换
      const date = new Date(time);
      const options = {
        timeZone: timezone,
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
      };
      
      const formatter = new Intl.DateTimeFormat('zh-CN', options);
      const parts = formatter.formatToParts(date);
      
      // 构建自定义格式
      const formatted = format
        .replace('YYYY', parts.find(p => p.type === 'year').value)
        .replace('MM', parts.find(p => p.type === 'month').value)
        .replace('DD', parts.find(p => p.type === 'day').value)
        .replace('HH', parts.find(p => p.type === 'hour').value)
        .replace('mm', parts.find(p => p.type === 'minute').value)
        .replace('ss', parts.find(p => p.type === 'second').value);
      
      return formatted;
    } catch (error) {
      console.error('时区转换错误:', error);
      return this.safeFormatTime(time, format);
    }
  }

  /**
   * 获取指定日期的开始时间（00:00:00）
   * @param {string|Date} date - 日期
   * @returns {string} 该日期开始时间的UTC字符串
   */
  static getDayStartTime(date) {
    if (!date) return '';
    const targetDate = dayjs(date);
    if (!targetDate.isValid()) return '';
    
    return targetDate.startOf('day').utc().toISOString();
  }

  /**
   * 获取指定日期的结束时间（23:59:59）
   * @param {string|Date} date - 日期
   * @returns {string} 该日期结束时间的UTC字符串
   */
  static getDayEndTime(date) {
    if (!date) return '';
    const targetDate = dayjs(date);
    if (!targetDate.isValid()) return '';
    
    return targetDate.endOf('day').utc().toISOString();
  }

  /**
   * 获取指定日期的前一天
   * @param {string|Date} date - 日期
   * @param {string} format - 返回格式
   * @returns {string} 前一天的日期字符串
   */
  static getPreviousDay(date, format = 'YYYY-MM-DD') {
    if (!date) return '';
    const targetDate = this.parseTime(date);
    
    return targetDate ? targetDate.subtract(1, 'day').format(format) : '';
  }

  /**
   * 获取指定日期的后一天
   * @param {string|Date} date - 日期
   * @param {string} format - 返回格式
   * @returns {string} 后一天的日期字符串
   */
  static getNextDay(date, format = 'YYYY-MM-DD') {
    if (!date) return '';
    const targetDate = this.parseTime(date);
    
    return targetDate ? targetDate.add(1, 'day').format(format) : '';
  }

  /**
   * 获取日期范围数组
   * @param {string|Date} startDate - 开始日期
   * @param {string|Date} endDate - 结束日期
   * @param {string} format - 返回格式
   * @returns {string[]} 日期数组
   */
  static getDateRange(startDate, endDate, format = 'YYYY-MM-DD') {
    const start = this.parseTime(startDate);
    const end = this.parseTime(endDate);
    
    if (!start || !end || start.isAfter(end)) return [];
    
    const dates = [];
    let current = start;
    
    while (current.isBefore(end) || current.isSame(end, 'day')) {
      dates.push(current.format(format));
      current = current.add(1, 'day');
    }
    
    return dates;
  }

  /**
   * 获取时间状态信息
   * @param {string|Date} time - 时间
   * @returns {Object} 时间状态对象 {status, text, color}
   */
  static getTimeStatus(time) {
    if (!time) return { status: 'invalid', text: '--', color: 'gray' };
    
    const targetTime = this.parseTime(time);
    const now = dayjs();
    const diff = now.diff(targetTime, 'minute');
    
    if (diff < 5) return { status: 'new', text: '刚刚', color: 'green' };
    if (diff < 30) return { status: 'recent', text: `${diff}分钟前`, color: 'blue' };
    if (diff < 60) return { status: 'old', text: `${Math.floor(diff / 60)}小时前`, color: 'orange' };
    if (diff < 1440) return { status: 'very-old', text: `${Math.floor(diff / 1440)}天前`, color: 'red' };
    
    return { status: 'past', text: this.formatTime(time, 'YYYY-MM-DD'), color: 'gray' };
  }
}

/**
 * 时间格式化缓存工具类
 * 用于优化大量数据的时间格式化性能
 */
export class TimeCache {
  static cache = new Map();
  static maxSize = 1000; // 缓存最大条目数
  
  /**
   * 格式化时间并缓存结果
   * @param {string|Date} time - 时间
   * @param {string} format - 格式
   * @returns {string} 格式化后的时间
   */
  static format(time, format) {
    if (!time) return '';
    
    const key = `${time}_${format}`;
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    
    // 缓存大小控制
    if (this.cache.size >= this.maxSize) {
      // 删除最早添加的缓存项
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    const formatted = TimeUtils.formatTime(time, format);
    this.cache.set(key, formatted);
    return formatted;
  }
  
  /**
   * 清除缓存
   */
  static clear() {
    this.cache.clear();
  }
  
  /**
   * 获取缓存大小
   * @returns {number} 缓存条目数
   */
  static getSize() {
    return this.cache.size;
  }
}

export default TimeUtils;
```

## 🎨 Vue组件使用示例

### 1. Vue 2 全局过滤器

在 `main.js` 中配置：

```javascript
import Vue from 'vue';
import { TimeUtils } from '@/utils/TimeUtils';

// 注册全局过滤器
Vue.filter('formatTime', function(time, format = 'YYYY-MM-DD HH:mm') {
  return TimeUtils.formatTime(time, format);
});

Vue.filter('relativeTime', function(time) {
  return TimeUtils.getRelativeTime(time);
});

Vue.filter('safeFormatTime', function(time, format = 'YYYY-MM-DD HH:mm:ss') {
  return TimeUtils.safeFormatTime(time, format);
});
```

在模板中使用：

```vue
<template>
  <div class="order-item">
    <h3>{{ order.title }}</h3>
    <p>创建时间: {{ order.createTime | formatTime('YYYY-MM-DD HH:mm') }}</p>
    <p>更新时间: {{ order.updateTime | relativeTime }}</p>
    <p>状态: {{ order.status | safeFormatTime }}</p>
  </div>
</template>
```

### 2. Vue 3 Composition API

```vue
<template>
  <div class="order-item">
    <h3>{{ order.title }}</h3>
    <p>创建时间: {{ formatTime(order.createTime, 'YYYY-MM-DD HH:mm') }}</p>
    <p>更新时间: {{ getRelativeTime(order.updateTime) }}</p>
    <p>状态: {{ safeFormatTime(order.status) }}</p>
  </div>
</template>

<script setup>
import { computed } from 'vue';
import { TimeUtils } from '@/utils/TimeUtils';

const props = defineProps(['order']);

const formatTime = (time, format) => {
  return TimeUtils.formatTime(time, format);
};

const getRelativeTime = (time) => {
  return TimeUtils.getRelativeTime(time);
};

const safeFormatTime = (time, format) => {
  return TimeUtils.safeFormatTime(time, format);
};
</script>
```

### 3. 表格组件示例

```vue
<template>
  <el-table :data="tableData" style="width: 100%">
    <el-table-column prop="orderId" label="订单ID" width="180" />
    
    <el-table-column prop="createTime" label="创建时间" width="180">
      <template #default="{ row }">
        {{ formatTime(row.createTime, 'YYYY-MM-DD HH:mm') }}
      </template>
    </el-table-column>
    
    <el-table-column prop="updateTime" label="更新时间" width="180">
      <template #default="{ row }">
        <span :title="formatTime(row.updateTime, 'YYYY-MM-DD HH:mm:ss')">
          {{ getRelativeTime(row.updateTime) }}
        </span>
      </template>
    </el-table-column>
    
    <el-table-column prop="status" label="状态" width="120">
      <template #default="{ row }">
        <el-tag :type="getTimeStatus(row.updateTime).color">
          {{ getTimeStatus(row.updateTime).text }}
        </el-tag>
      </template>
    </el-table-column>
  </el-table>
</template>

<script setup>
import { TimeUtils } from '@/utils/TimeUtils';

const formatTime = (time, format) => TimeUtils.formatTime(time, format);
const getRelativeTime = (time) => TimeUtils.getRelativeTime(time);
const getTimeStatus = (time) => TimeUtils.getTimeStatus(time);
</script>
```

### 4. 表单组件示例

```vue
<template>
  <el-form @submit="handleSubmit">
    <el-form-item label="日期">
      <el-date-picker
        v-model="form.date"
        type="date"
        placeholder="选择日期"
        format="YYYY-MM-DD"
        value-format="YYYY-MM-DD"
      />
    </el-form-item>
    
    <el-form-item label="时间">
      <el-time-picker
        v-model="form.time"
        placeholder="选择时间"
        format="HH:mm"
        value-format="HH:mm"
      />
    </el-form-item>
    
    <el-form-item label="时间范围">
      <el-date-picker
        v-model="form.dateRange"
        type="datetimerange"
        range-separator="至"
        start-placeholder="开始时间"
        end-placeholder="结束时间"
        format="YYYY-MM-DD HH:mm"
        value-format="YYYY-MM-DDTHH:mm:ss.sssZ"
      />
    </el-form-item>
    
    <el-button type="primary" @click="handleSubmit">提交</el-button>
  </el-form>
</template>

<script setup>
import { ref } from 'vue';
import { TimeUtils } from '@/utils/TimeUtils';

const form = ref({
  date: TimeUtils.getCurrentDate(),
  time: TimeUtils.getCurrentTime(),
  dateRange: []
});

const handleSubmit = () => {
  // 组合日期和时间
  const localDateTime = `${form.value.date} ${form.value.time}`;
  
  // 转换为UTC时间提交给后端
  const utcDateTime = TimeUtils.toUTCForSubmit(localDateTime);
  
  // 处理时间范围
  const startTime = TimeUtils.toUTCForSubmit(form.value.dateRange[0]);
  const endTime = TimeUtils.toUTCForSubmit(form.value.dateRange[1]);
  
  // 提交数据
  const submitData = {
    eventTime: utcDateTime,
    startTime: startTime,
    endTime: endTime
  };
  
  console.log('提交数据:', submitData);
  // 调用API提交数据
};
</script>
```

## ⚛️ React组件使用示例

### 1. 自定义Hook

创建 `src/hooks/useTime.js`：

```javascript
import { useMemo } from 'react';
import { TimeUtils } from '@/utils/TimeUtils';

export const useTime = () => {
  const formatTime = useMemo(() => {
    return (time, format) => TimeUtils.formatTime(time, format);
  }, []);

  const getRelativeTime = useMemo(() => {
    return (time) => TimeUtils.getRelativeTime(time);
  }, []);

  const safeFormatTime = useMemo(() => {
    return (time, format) => TimeUtils.safeFormatTime(time, format);
  }, []);

  const getTimeStatus = useMemo(() => {
    return (time) => TimeUtils.getTimeStatus(time);
  }, []);

  return {
    formatTime,
    getRelativeTime,
    safeFormatTime,
    getTimeStatus,
    getCurrentDate: TimeUtils.getCurrentDate,
    getCurrentTime: TimeUtils.getCurrentTime,
    toUTCForSubmit: TimeUtils.toUTCForSubmit
  };
};
```

### 2. 时间显示组件

```jsx
import React from 'react';
import { useTime } from '@/hooks/useTime';

const TimeDisplay = ({ item }) => {
  const { formatTime, getRelativeTime, getTimeStatus } = useTime();

  return (
    <div className="time-display">
      <p>创建时间: {formatTime(item.createTime, 'YYYY-MM-DD HH:mm')}</p>
      <p>更新时间: {getRelativeTime(item.updateTime)}</p>
      <span className={`status ${getTimeStatus(item.updateTime).color}`}>
        {getTimeStatus(item.updateTime).text}
      </span>
    </div>
  );
};

export default TimeDisplay;
```

### 3. 表格组件

```jsx
import React from 'react';
import { useTime } from '@/hooks/useTime';

const OrderTable = ({ data }) => {
  const { formatTime, getRelativeTime, getTimeStatus } = useTime();

  return (
    <table className="order-table">
      <thead>
        <tr>
          <th>订单ID</th>
          <th>创建时间</th>
          <th>更新时间</th>
          <th>状态</th>
        </tr>
      </thead>
      <tbody>
        {data.map((row) => (
          <tr key={row.id}>
            <td>{row.orderId}</td>
            <td>{formatTime(row.createTime, 'YYYY-MM-DD HH:mm')}</td>
            <td title={formatTime(row.updateTime, 'YYYY-MM-DD HH:mm:ss')}>
              {getRelativeTime(row.updateTime)}
            </td>
            <td>
              <span className={`status-tag ${getTimeStatus(row.updateTime).color}`}>
                {getTimeStatus(row.updateTime).text}
              </span>
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  );
};

export default OrderTable;
```

### 4. 表单组件

```jsx
import React, { useState } from 'react';
import { useTime } from '@/hooks/useTime';

const TimeForm = () => {
  const { getCurrentDate, getCurrentTime, toUTCForSubmit } = useTime();
  const [form, setForm] = useState({
    date: getCurrentDate(),
    time: getCurrentTime(),
    dateRange: []
  });

  const handleSubmit = () => {
    // 组合日期和时间
    const localDateTime = `${form.date} ${form.time}`;
    
    // 转换为UTC时间提交给后端
    const utcDateTime = toUTCForSubmit(localDateTime);
    
    // 处理时间范围
    const startTime = toUTCForSubmit(form.dateRange[0]);
    const endTime = toUTCForSubmit(form.dateRange[1]);
    
    const submitData = {
      eventTime: utcDateTime,
      startTime: startTime,
      endTime: endTime
    };
    
    console.log('提交数据:', submitData);
    // 调用API提交数据
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>日期:</label>
        <input
          type="date"
          value={form.date}
          onChange={(e) => setForm({...form, date: e.target.value})}
        />
      </div>
      
      <div>
        <label>时间:</label>
        <input
          type="time"
          value={form.time}
          onChange={(e) => setForm({...form, time: e.target.value})}
        />
      </div>
      
      <button type="submit">提交</button>
    </form>
  );
};

export default TimeForm;
```

## 🔧 API接口对接

### 1. 请求数据格式

```javascript
// 前端提交给后端的时间格式
const submitData = {
  eventTime: '2024-01-15T10:30:00.000Z',  // UTC时间
  deadline: '2024-01-20T18:00:00.000Z',   // UTC时间
  date: '2024-01-15',                      // 仅日期
  startTime: '14:00',                      // 仅时间
  endTime: '16:00'                         // 仅时间
};
```

### 2. 响应数据格式

```javascript
// 后端返回的时间格式
const responseData = {
  orderId: 'order-123',
  createTime: '2024-01-15T10:30:00.000Z',  // UTC时间
  updateTime: '2024-01-15T14:25:30.500Z',  // UTC时间
  diningDate: '2024-01-15',                // 仅日期
  mealType: 'dinner'
};
```

### 3. API调用示例

```javascript
import { TimeUtils } from '@/utils/TimeUtils';

// 获取数据
const fetchOrders = async () => {
  try {
    const response = await fetch('/api/orders');
    const data = await response.json();
    
    // 数据已经包含UTC时间，直接使用TimeUtils格式化显示
    return data.map(order => ({
      ...order,
      createTimeDisplay: TimeUtils.formatTime(order.createTime, 'YYYY-MM-DD HH:mm'),
      updateTimeDisplay: TimeUtils.getRelativeTime(order.updateTime)
    }));
  } catch (error) {
    console.error('获取订单失败:', error);
  }
};

// 提交数据
const submitOrder = async (formData) => {
  try {
    const submitData = {
      ...formData,
      eventTime: TimeUtils.toUTCForSubmit(formData.eventTime),
      deadline: TimeUtils.toUTCForSubmit(formData.deadline)
    };
    
    const response = await fetch('/api/orders', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(submitData)
    });
    
    return await response.json();
  } catch (error) {
    console.error('提交订单失败:', error);
  }
};
```

## 🎯 业务场景处理

### 1. 报餐时间处理

```javascript
// 检查是否可以报餐
const canOrderMeal = (mealType) => {
  const now = dayjs().utcOffset(8);
  const today = now.format('YYYY-MM-DD');
  
  // 定义各餐次的截止时间
  const deadlines = {
    'breakfast': `${today}T08:00:00`, // 早餐8点前
    'lunch': `${today}T11:00:00`,     // 午餐11点前
    'dinner': `${today}T17:00:00`     // 晚餐17点前
  };
  
  const deadline = dayjs(deadlines[mealType]).utcOffset(8);
  return now.isBefore(deadline);
};

// 使用示例
if (canOrderMeal('dinner')) {
  console.log('可以报晚餐');
} else {
  console.log('晚餐报餐时间已过');
}
```

### 2. 预约时间处理

```javascript
// 预约时间验证
const validateReservationTime = (date, startTime, endTime) => {
  const now = dayjs().utcOffset(8);
  const reservationDate = dayjs(`${date}T${startTime}:00`).utcOffset(8);
  
  // 检查是否在未来
  if (reservationDate.isBefore(now)) {
    return { valid: false, message: '预约时间必须是未来时间' };
  }
  
  // 检查时间范围
  const start = dayjs(`2000-01-01T${startTime}:00`).utcOffset(8);
  const end = dayjs(`2000-01-01T${endTime}:00`).utcOffset(8);
  const duration = end.diff(start, 'minute');
  
  if (duration <= 0) {
    return { valid: false, message: '结束时间必须晚于开始时间' };
  }
  
  return { valid: true };
};
```

### 3. 时间范围查询

```javascript
// 获取日期范围
const getDateRange = (startDate, endDate) => {
  return TimeUtils.getDateRange(startDate, endDate);
};

// 获取时间范围查询参数
const getTimeRangeQuery = (date) => {
  return {
    startTime: TimeUtils.getDayStartTime(date),
    endTime: TimeUtils.getDayEndTime(date)
  };
};

// 使用示例
const queryParams = getTimeRangeQuery('2024-01-15');
// 结果: { startTime: '2024-01-15T00:00:00.000Z', endTime: '2024-01-15T23:59:59.999Z' }
```

## ⚡ 性能优化

### 1. 时间格式化缓存

```javascript
import { TimeCache } from '@/utils/TimeUtils';

// 在大量数据渲染时使用缓存
const formatTimeWithCache = (time, format) => {
  return TimeCache.format(time, format);
};

// 清除缓存（在数据更新后）
const clearTimeCache = () => {
  TimeCache.clear();
};
```

### 2. 延迟格式化

```jsx
// React示例 - 延迟格式化避免阻塞渲染
const TimeCell = ({ time, format }) => {
  const [formattedTime, setFormattedTime] = useState('');
  
  useEffect(() => {
    // 延迟格式化，避免阻塞渲染
    const timer = setTimeout(() => {
      setFormattedTime(TimeUtils.formatTime(time, format));
    }, 0);
    
    return () => clearTimeout(timer);
  }, [time, format]);
  
  return <span>{formattedTime}</span>;
};
```

### 3. 虚拟滚动优化

```jsx
// 在虚拟滚动中使用延迟格式化
const VirtualizedTimeList = ({ items }) => {
  const [visibleItems, setVisibleItems] = useState([]);
  
  useEffect(() => {
    // 只格式化可见项
    const formatted = visibleItems.map(item => ({
      ...item,
      formattedTime: TimeUtils.formatTime(item.time)
    }));
    setVisibleItems(formatted);
  }, [visibleItems]);
  
  return (
    <div>
      {visibleItems.map(item => (
        <div key={item.id}>
          {item.formattedTime}
        </div>
      ))}
    </div>
  );
};
```

## 🚨 错误处理

### 1. 安全格式化

```javascript
// 使用安全格式化避免错误
const safeDisplay = TimeUtils.safeFormatTime(time, 'YYYY-MM-DD HH:mm');
// 如果时间无效，返回 '--' 或 '无效时间'
```

### 2. 时间验证

```javascript
// 验证时间格式
const validateTime = (timeString) => {
  if (!TimeUtils.isValidTime(timeString)) {
    throw new Error('无效的时间格式');
  }
  return true;
};
```

### 3. 错误边界

```jsx
// React错误边界
class TimeErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error('时间处理错误:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <div>时间显示错误</div>;
    }

    return this.props.children;
  }
}
```

## 📋 最佳实践

### 1. 统一使用工具类

```javascript
// ✅ 正确 - 使用工具类
const displayTime = TimeUtils.formatTime(time, 'YYYY-MM-DD HH:mm');

// ❌ 错误 - 直接使用原生Date
const displayTime = new Date(time).toLocaleString();
```

### 2. 明确时区处理

```javascript
// ✅ 正确 - 明确指定时区转换
const beijingTime = dayjs(time).utcOffset(8).format('YYYY-MM-DD HH:mm');

// ❌ 错误 - 依赖系统时区
const localTime = dayjs(time).format('YYYY-MM-DD HH:mm');
```

### 3. 统一时间格式

```javascript
// ✅ 正确 - 使用标准格式
const utcTime = '2024-01-15T10:30:00.000Z';
const beijingTime = '2024-01-15 18:30:00';

// ❌ 错误 - 使用非标准格式
const utcTime = '2024-01-15 10:30:00';
const beijingTime = '2024-01-15T18:30:00+08:00';
```

### 4. 性能考虑

```javascript
// ✅ 正确 - 使用缓存
const formattedTime = TimeCache.format(time, format);

// ✅ 正确 - 延迟格式化
setTimeout(() => {
  setFormattedTime(TimeUtils.formatTime(time, format));
}, 0);

// ❌ 错误 - 重复格式化
const formattedTime = TimeUtils.formatTime(time, format); // 每次都重新计算
```

## 🔍 调试技巧

### 1. 时间调试工具

```javascript
// 创建时间调试工具
const debugTime = (time, label = '') => {
  console.log(`${label}:`, {
    original: time,
    parsed: TimeUtils.parseTime(time),
    beijing: TimeUtils.formatTime(time, 'YYYY-MM-DD HH:mm:ss'),
    utc: TimeUtils.toUTCForSubmit(time),
    isValid: TimeUtils.isValidTime(time)
  });
};

// 使用示例
debugTime('2024-01-15T10:30:00.000Z', 'API返回时间');
debugTime('2024-01-15 18:30:00', '用户输入时间');
```

### 2. 时区检查

```javascript
// 检查当前时区设置
const checkTimezone = () => {
  console.log('当前时区信息:', {
    systemTimezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    utcTime: dayjs().utc().format('YYYY-MM-DD HH:mm:ss'),
    beijingTime: dayjs().utcOffset(8).format('YYYY-MM-DD HH:mm:ss'),
    localTime: dayjs().format('YYYY-MM-DD HH:mm:ss')
  });
};
```

## 📚 总结

通过遵循本文档的规范和实践，前端开发人员可以：

1. **统一时间处理**：使用统一的时间处理工具类
2. **正确显示时间**：将UTC时间正确转换为北京时间显示
3. **正确提交时间**：将北京时间正确转换为UTC时间提交
4. **优化性能**：使用缓存和延迟格式化优化性能
5. **处理错误**：使用安全格式化避免时间处理错误

遵循这些规范可以确保时间数据在整个系统中的一致性和准确性，避免时区相关的问题。

## 📞 技术支持

如有问题，请参考：
- [前端对接快速指南](./前端对接快速指南.md)
- [前端API接口时间处理文档](./前端API接口时间处理文档.md)
- [统一时间处理方案及前端对接文档](./统一时间处理方案及前端对接文档.md)

---

**注意**：本文档基于统一时间处理方案，请确保后端也遵循相应的时间处理规范。