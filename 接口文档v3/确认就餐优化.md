# å‰ç«¯ç¡®è®¤å°±é¤è¯·æ±‚å¤„ç†æ–‡æ¡£

## æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è¯´æ˜å‰ç«¯å¦‚ä½•æ­£ç¡®å‘èµ·ç¡®è®¤å°±é¤è¯·æ±‚ï¼ŒåŒ…æ‹¬æ—¶åŒºå¤„ç†ã€é”™è¯¯å¤„ç†ã€ç”¨æˆ·ä½“éªŒä¼˜åŒ–å’Œæœ€ä½³å®è·µã€‚

## 1. ç¡®è®¤å°±é¤æ¥å£è¯´æ˜

### 1.1 æ¥å£ä¿¡æ¯
- **URL**: `POST /api/dining-confirmation/manual/{orderId}`
- **æƒé™**: éœ€è¦ç”¨æˆ·ç™»å½•è®¤è¯
- **åŠŸèƒ½**: ç”¨æˆ·æ‰‹åŠ¨ç¡®è®¤å°±é¤

### 1.2 è¯·æ±‚å‚æ•°
```javascript
// URLå‚æ•°
orderId: string  // è®¢å•ID

// è¯·æ±‚ä½“ï¼ˆå¯é€‰ï¼‰
{
  "confirmationType": "manual",  // ç¡®è®¤ç±»å‹ï¼Œé»˜è®¤ä¸º "manual"
  "remark": "å¤‡æ³¨ä¿¡æ¯"           // å¯é€‰å¤‡æ³¨
}
```

### 1.3 å“åº”æ ¼å¼
```javascript
// æˆåŠŸå“åº”
{
  "success": true,
  "data": {
    "orderId": "è®¢å•ID",
    "confirmationType": "manual",
    "actualDiningTime": "2025-09-11 18:30:00",  // åŒ—äº¬æ—¶é—´
    "message": "ç¡®è®¤å°±é¤æˆåŠŸ"
  },
  "message": "ç¡®è®¤å°±é¤æˆåŠŸ"
}

// é”™è¯¯å“åº”
{
  "success": false,
  "message": "é”™è¯¯ä¿¡æ¯",
  "data": null,
  "code": "400"
}
```

## 2. å‰ç«¯å®ç°æ–¹æ¡ˆ

### 2.1 åŸºç¡€è¯·æ±‚å‡½æ•°

```javascript
// utils/api.js
import axios from 'axios';
import moment from 'moment-timezone';

class DiningApi {
  constructor() {
    this.baseURL = process.env.VUE_APP_API_BASE_URL || 'http://localhost:3000/api';
    this.axios = axios.create({
      baseURL: this.baseURL,
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    // æ·»åŠ è¯·æ±‚æ‹¦æˆªå™¨ï¼Œè‡ªåŠ¨æ·»åŠ è®¤è¯token
    this.axios.interceptors.request.use(
      (config) => {
        const token = localStorage.getItem('auth_token');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );
    
    // æ·»åŠ å“åº”æ‹¦æˆªå™¨ï¼Œç»Ÿä¸€å¤„ç†é”™è¯¯
    this.axios.interceptors.response.use(
      (response) => response.data,
      (error) => {
        const message = error.response?.data?.message || 'è¯·æ±‚å¤±è´¥';
        throw new Error(message);
      }
    );
  }

  /**
   * ç¡®è®¤å°±é¤
   * @param {string} orderId - è®¢å•ID
   * @param {Object} options - å¯é€‰å‚æ•°
   * @returns {Promise} ç¡®è®¤ç»“æœ
   */
  async confirmDining(orderId, options = {}) {
    try {
      const response = await this.axios.post(
        `/dining-confirmation/manual/${orderId}`,
        {
          confirmationType: 'manual',
          ...options
        }
      );
      return response;
    } catch (error) {
      throw new Error(error.message);
    }
  }

  /**
   * è·å–å°±é¤çŠ¶æ€
   * @param {string} date - æ—¥æœŸ (YYYY-MM-DD)
   * @returns {Promise} å°±é¤çŠ¶æ€
   */
  async getDiningStatus(date) {
    try {
      const response = await this.axios.get('/dining-confirmation/status', {
        params: { date }
      });
      return response;
    } catch (error) {
      throw new Error(error.message);
    }
  }
}

export default new DiningApi();
```

### 2.2 æ—¶é—´å¤„ç†å·¥å…·

```javascript
// utils/timeUtils.js
import moment from 'moment-timezone';

class TimeUtils {
  /**
   * è·å–å½“å‰åŒ—äº¬æ—¶é—´
   * @returns {moment.Moment} åŒ—äº¬æ—¶é—´
   */
  static getBeijingTime() {
    return moment().tz('Asia/Shanghai');
  }

  /**
   * æ£€æŸ¥æ˜¯å¦åœ¨å°±é¤æ—¶é—´å†…
   * @param {string} mealType - é¤æ¬¡ç±»å‹
   * @returns {Object} æ£€æŸ¥ç»“æœ
   */
  static checkMealTime(mealType) {
    const now = this.getBeijingTime();
    const currentHour = now.hour();
    
    const mealTimeRanges = {
      'breakfast': { start: 6, end: 10, name: 'æ—©é¤' },
      'lunch': { start: 11, end: 14, name: 'åˆé¤' },
      'dinner': { start: 17, end: 20, name: 'æ™šé¤' }
    };

    const timeRange = mealTimeRanges[mealType];
    if (!timeRange) {
      return { valid: false, message: 'æ— æ•ˆçš„é¤æ¬¡ç±»å‹' };
    }

    const isValid = currentHour >= timeRange.start && currentHour <= timeRange.end;
    
    return {
      valid: isValid,
      message: isValid 
        ? `å½“å‰æ—¶é—´å¯ä»¥ç¡®è®¤${timeRange.name}å°±é¤`
        : `å½“å‰æ—¶é—´ä¸åœ¨${timeRange.name}å°±é¤æ—¶é—´å†… (${timeRange.start}:00-${timeRange.end}:00)`,
      currentTime: now.format('HH:mm:ss'),
      timeRange: `${timeRange.start}:00-${timeRange.end}:00`
    };
  }

  /**
   * æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤º
   * @param {string} timeString - æ—¶é—´å­—ç¬¦ä¸²
   * @param {string} format - æ ¼å¼
   * @returns {string} æ ¼å¼åŒ–åçš„æ—¶é—´
   */
  static formatTime(timeString, format = 'YYYY-MM-DD HH:mm:ss') {
    if (!timeString) return '';
    return moment(timeString).tz('Asia/Shanghai').format(format);
  }

  /**
   * è·å–ç›¸å¯¹æ—¶é—´
   * @param {string} timeString - æ—¶é—´å­—ç¬¦ä¸²
   * @returns {string} ç›¸å¯¹æ—¶é—´
   */
  static getRelativeTime(timeString) {
    if (!timeString) return '';
    const time = moment(timeString).tz('Asia/Shanghai');
    const now = this.getBeijingTime();
    return time.from(now);
  }
}

export default TimeUtils;
```

### 2.3 Vueç»„ä»¶å®ç°

```vue
<!-- components/DiningConfirmation.vue -->
<template>
  <div class="dining-confirmation">
    <!-- å°±é¤çŠ¶æ€å¡ç‰‡ -->
    <div 
      v-for="meal in meals" 
      :key="meal.type"
      class="meal-card"
      :class="{ 
        'can-confirm': meal.canConfirm,
        'confirmed': meal.status === 'dined',
        'disabled': !meal.canConfirm && meal.status !== 'dined'
      }"
    >
      <div class="meal-header">
        <h3>{{ meal.name }}</h3>
        <span class="status-badge" :class="meal.statusClass">
          {{ meal.statusText }}
        </span>
      </div>
      
      <div class="meal-info">
        <p>æŠ¥é¤æ—¶é—´: {{ meal.orderTime }}</p>
        <p v-if="meal.diningTime">å°±é¤æ—¶é—´: {{ meal.diningTime }}</p>
        <p class="time-range">å°±é¤æ—¶é—´èŒƒå›´: {{ meal.timeRange }}</p>
      </div>
      
      <div class="meal-actions">
        <button 
          v-if="meal.canConfirm"
          @click="confirmMeal(meal)"
          :disabled="confirming"
          class="confirm-btn"
        >
          <i class="icon-check"></i>
          {{ confirming ? 'ç¡®è®¤ä¸­...' : 'ç¡®è®¤å°±é¤' }}
        </button>
        
        <div v-else-if="meal.status !== 'dined'" class="time-hint">
          <i class="icon-clock"></i>
          {{ meal.timeHint }}
        </div>
        
        <div v-else class="confirmed-info">
          <i class="icon-check-circle"></i>
          å·²ç¡®è®¤å°±é¤
        </div>
      </div>
    </div>
    
    <!-- åŠ è½½çŠ¶æ€ -->
    <div v-if="loading" class="loading">
      <i class="icon-loading"></i>
      åŠ è½½ä¸­...
    </div>
    
    <!-- é”™è¯¯æç¤º -->
    <div v-if="error" class="error-message">
      <i class="icon-error"></i>
      {{ error }}
    </div>
  </div>
</template>

<script>
import DiningApi from '@/utils/api';
import TimeUtils from '@/utils/timeUtils';
import { showToast, showConfirm } from '@/utils/ui';

export default {
  name: 'DiningConfirmation',
  data() {
    return {
      meals: [],
      loading: false,
      confirming: false,
      error: null,
      selectedDate: null
    };
  },
  
  computed: {
    currentDate() {
      return TimeUtils.getBeijingTime().format('YYYY-MM-DD');
    }
  },
  
  async mounted() {
    await this.loadDiningStatus();
  },
  
  methods: {
    /**
     * åŠ è½½å°±é¤çŠ¶æ€
     */
    async loadDiningStatus() {
      try {
        this.loading = true;
        this.error = null;
        
        const date = this.selectedDate || this.currentDate;
        const response = await DiningApi.getDiningStatus(date);
        
        this.meals = this.processMealsData(response.data);
      } catch (error) {
        this.error = error.message;
        showToast('åŠ è½½å°±é¤çŠ¶æ€å¤±è´¥', 'error');
      } finally {
        this.loading = false;
      }
    },
    
    /**
     * å¤„ç†é¤æ¬¡æ•°æ®
     */
    processMealsData(mealsData) {
      const mealTypes = {
        'breakfast': { name: 'æ—©é¤', order: 1 },
        'lunch': { name: 'åˆé¤', order: 2 },
        'dinner': { name: 'æ™šé¤', order: 3 }
      };
      
      return mealsData.map(meal => {
        const mealInfo = mealTypes[meal.mealType];
        const timeCheck = TimeUtils.checkMealTime(meal.mealType);
        
        return {
          ...meal,
          name: mealInfo.name,
          order: mealInfo.order,
          canConfirm: timeCheck.valid && meal.diningStatus === 'ordered',
          timeHint: timeCheck.message,
          timeRange: timeCheck.timeRange,
          statusClass: this.getStatusClass(meal.diningStatus),
          statusText: this.getStatusText(meal.diningStatus),
          orderTime: TimeUtils.getRelativeTime(meal.createTime),
          diningTime: meal.actualDiningTime 
            ? TimeUtils.formatTime(meal.actualDiningTime, 'MM-DD HH:mm')
            : null
        };
      }).sort((a, b) => a.order - b.order);
    },
    
    /**
     * ç¡®è®¤å°±é¤
     */
    async confirmMeal(meal) {
      try {
        // äºŒæ¬¡ç¡®è®¤
        const confirmed = await showConfirm(
          'ç¡®è®¤å°±é¤',
          `ç¡®å®šè¦ç¡®è®¤${meal.name}å°±é¤å—ï¼Ÿç¡®è®¤åæ— æ³•æ’¤é”€ã€‚`
        );
        
        if (!confirmed) return;
        
        this.confirming = true;
        
        const response = await DiningApi.confirmDining(meal.orderId);
        
        // æ›´æ–°æœ¬åœ°çŠ¶æ€
        meal.status = 'dined';
        meal.diningTime = TimeUtils.formatTime(response.actualDiningTime, 'MM-DD HH:mm');
        meal.canConfirm = false;
        meal.statusClass = 'confirmed';
        meal.statusText = 'å·²å°±é¤';
        
        showToast('ç¡®è®¤å°±é¤æˆåŠŸ', 'success');
        
        // è§¦å‘çˆ¶ç»„ä»¶æ›´æ–°
        this.$emit('confirmed', meal);
        
      } catch (error) {
        this.handleConfirmError(error, meal);
      } finally {
        this.confirming = false;
      }
    },
    
    /**
     * å¤„ç†ç¡®è®¤é”™è¯¯
     */
    handleConfirmError(error, meal) {
      console.error('ç¡®è®¤å°±é¤å¤±è´¥:', error);
      
      // æ ¹æ®é”™è¯¯ç±»å‹æ˜¾ç¤ºä¸åŒæç¤º
      if (error.message.includes('æ—¶é—´ä¸åœ¨')) {
        showToast('å½“å‰æ—¶é—´ä¸åœ¨å°±é¤æ—¶é—´å†…ï¼Œæ— æ³•ç¡®è®¤', 'warning');
      } else if (error.message.includes('å·²ç¡®è®¤')) {
        showToast('è¯¥è®¢å•å·²ç¡®è®¤å°±é¤', 'info');
        meal.status = 'dined';
        meal.canConfirm = false;
      } else if (error.message.includes('å·²å–æ¶ˆ')) {
        showToast('è¯¥è®¢å•å·²å–æ¶ˆï¼Œæ— æ³•ç¡®è®¤', 'error');
        meal.status = 'cancelled';
        meal.canConfirm = false;
      } else {
        showToast(`ç¡®è®¤å¤±è´¥: ${error.message}`, 'error');
      }
    },
    
    /**
     * è·å–çŠ¶æ€æ ·å¼ç±»
     */
    getStatusClass(status) {
      const statusClasses = {
        'ordered': 'status-ordered',
        'dined': 'status-confirmed',
        'cancelled': 'status-cancelled'
      };
      return statusClasses[status] || 'status-unknown';
    },
    
    /**
     * è·å–çŠ¶æ€æ–‡æœ¬
     */
    getStatusText(status) {
      const statusTexts = {
        'ordered': 'å·²æŠ¥é¤',
        'dined': 'å·²å°±é¤',
        'cancelled': 'å·²å–æ¶ˆ'
      };
      return statusTexts[status] || 'æœªçŸ¥';
    },
    
    /**
     * åˆ·æ–°æ•°æ®
     */
    async refresh() {
      await this.loadDiningStatus();
    }
  }
};
</script>

<style scoped>
.dining-confirmation {
  padding: 20px;
}

.meal-card {
  background: white;
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 16px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;
}

.meal-card.can-confirm {
  border-left: 4px solid #52c41a;
}

.meal-card.confirmed {
  border-left: 4px solid #1890ff;
  background: #f6ffed;
}

.meal-card.disabled {
  opacity: 0.6;
  border-left: 4px solid #d9d9d9;
}

.meal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.meal-header h3 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
}

.status-badge {
  padding: 4px 12px;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 500;
}

.status-ordered {
  background: #fff7e6;
  color: #d46b08;
}

.status-confirmed {
  background: #f6ffed;
  color: #52c41a;
}

.status-cancelled {
  background: #fff2f0;
  color: #ff4d4f;
}

.meal-info {
  margin-bottom: 16px;
}

.meal-info p {
  margin: 4px 0;
  color: #666;
  font-size: 14px;
}

.time-range {
  color: #999 !important;
  font-size: 12px !important;
}

.meal-actions {
  text-align: center;
}

.confirm-btn {
  background: #52c41a;
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 16px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s ease;
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.confirm-btn:hover:not(:disabled) {
  background: #389e0d;
  transform: translateY(-1px);
}

.confirm-btn:disabled {
  background: #d9d9d9;
  cursor: not-allowed;
  transform: none;
}

.time-hint {
  color: #ff7875;
  font-size: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.confirmed-info {
  color: #52c41a;
  font-size: 14px;
  font-weight: 500;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.loading {
  text-align: center;
  padding: 40px;
  color: #666;
}

.error-message {
  background: #fff2f0;
  color: #ff4d4f;
  padding: 16px;
  border-radius: 8px;
  margin: 16px 0;
  display: flex;
  align-items: center;
  gap: 8px;
}

.icon-check::before { content: 'âœ“'; }
.icon-clock::before { content: 'ğŸ•'; }
.icon-check-circle::before { content: 'âœ“'; }
.icon-loading::before { content: 'âŸ³'; }
.icon-error::before { content: 'âš '; }
</style>
```

### 2.4 React Hookå®ç°

```javascript
// hooks/useDiningConfirmation.js
import { useState, useEffect, useCallback } from 'react';
import DiningApi from '@/utils/api';
import TimeUtils from '@/utils/timeUtils';

export const useDiningConfirmation = (selectedDate) => {
  const [meals, setMeals] = useState([]);
  const [loading, setLoading] = useState(false);
  const [confirming, setConfirming] = useState(false);
  const [error, setError] = useState(null);

  /**
   * åŠ è½½å°±é¤çŠ¶æ€
   */
  const loadDiningStatus = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const date = selectedDate || TimeUtils.getBeijingTime().format('YYYY-MM-DD');
      const response = await DiningApi.getDiningStatus(date);
      
      const processedMeals = processMealsData(response.data);
      setMeals(processedMeals);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [selectedDate]);

  /**
   * å¤„ç†é¤æ¬¡æ•°æ®
   */
  const processMealsData = (mealsData) => {
    const mealTypes = {
      'breakfast': { name: 'æ—©é¤', order: 1 },
      'lunch': { name: 'åˆé¤', order: 2 },
      'dinner': { name: 'æ™šé¤', order: 3 }
    };
    
    return mealsData.map(meal => {
      const mealInfo = mealTypes[meal.mealType];
      const timeCheck = TimeUtils.checkMealTime(meal.mealType);
      
      return {
        ...meal,
        name: mealInfo.name,
        order: mealInfo.order,
        canConfirm: timeCheck.valid && meal.diningStatus === 'ordered',
        timeHint: timeCheck.message,
        timeRange: timeCheck.timeRange,
        statusClass: getStatusClass(meal.diningStatus),
        statusText: getStatusText(meal.diningStatus),
        orderTime: TimeUtils.getRelativeTime(meal.createTime),
        diningTime: meal.actualDiningTime 
          ? TimeUtils.formatTime(meal.actualDiningTime, 'MM-DD HH:mm')
          : null
      };
    }).sort((a, b) => a.order - b.order);
  };

  /**
   * ç¡®è®¤å°±é¤
   */
  const confirmMeal = useCallback(async (meal) => {
    try {
      setConfirming(true);
      
      const response = await DiningApi.confirmDining(meal.orderId);
      
      // æ›´æ–°æœ¬åœ°çŠ¶æ€
      setMeals(prevMeals => 
        prevMeals.map(m => 
          m.orderId === meal.orderId 
            ? {
                ...m,
                status: 'dined',
                diningTime: TimeUtils.formatTime(response.actualDiningTime, 'MM-DD HH:mm'),
                canConfirm: false,
                statusClass: 'confirmed',
                statusText: 'å·²å°±é¤'
              }
            : m
        )
      );
      
      return { success: true, data: response };
    } catch (err) {
      return { success: false, error: err.message };
    } finally {
      setConfirming(false);
    }
  }, []);

  /**
   * è·å–çŠ¶æ€æ ·å¼ç±»
   */
  const getStatusClass = (status) => {
    const statusClasses = {
      'ordered': 'status-ordered',
      'dined': 'status-confirmed',
      'cancelled': 'status-cancelled'
    };
    return statusClasses[status] || 'status-unknown';
  };

  /**
   * è·å–çŠ¶æ€æ–‡æœ¬
   */
  const getStatusText = (status) => {
    const statusTexts = {
      'ordered': 'å·²æŠ¥é¤',
      'dined': 'å·²å°±é¤',
      'cancelled': 'å·²å–æ¶ˆ'
    };
    return statusTexts[status] || 'æœªçŸ¥';
  };

  // åˆå§‹åŒ–åŠ è½½
  useEffect(() => {
    loadDiningStatus();
  }, [loadDiningStatus]);

  return {
    meals,
    loading,
    confirming,
    error,
    confirmMeal,
    refresh: loadDiningStatus
  };
};
```

## 3. é”™è¯¯å¤„ç†ç­–ç•¥

### 3.1 å¸¸è§é”™è¯¯ç±»å‹

```javascript
// utils/errorHandler.js
export const ErrorTypes = {
  TIME_INVALID: 'TIME_INVALID',           // æ—¶é—´ä¸åœ¨å°±é¤æ—¶é—´å†…
  ALREADY_CONFIRMED: 'ALREADY_CONFIRMED', // å·²ç¡®è®¤å°±é¤
  ORDER_CANCELLED: 'ORDER_CANCELLED',     // è®¢å•å·²å–æ¶ˆ
  ORDER_NOT_FOUND: 'ORDER_NOT_FOUND',     // è®¢å•ä¸å­˜åœ¨
  PERMISSION_DENIED: 'PERMISSION_DENIED', // æƒé™ä¸è¶³
  NETWORK_ERROR: 'NETWORK_ERROR',         // ç½‘ç»œé”™è¯¯
  SERVER_ERROR: 'SERVER_ERROR'            // æœåŠ¡å™¨é”™è¯¯
};

export class DiningError extends Error {
  constructor(message, type, details = null) {
    super(message);
    this.name = 'DiningError';
    this.type = type;
    this.details = details;
  }
}

export const handleDiningError = (error) => {
  const message = error.message || 'æœªçŸ¥é”™è¯¯';
  
  if (message.includes('æ—¶é—´ä¸åœ¨')) {
    return new DiningError(message, ErrorTypes.TIME_INVALID);
  } else if (message.includes('å·²ç¡®è®¤')) {
    return new DiningError(message, ErrorTypes.ALREADY_CONFIRMED);
  } else if (message.includes('å·²å–æ¶ˆ')) {
    return new DiningError(message, ErrorTypes.ORDER_CANCELLED);
  } else if (message.includes('ä¸å­˜åœ¨')) {
    return new DiningError(message, ErrorTypes.ORDER_NOT_FOUND);
  } else if (message.includes('æƒé™')) {
    return new DiningError(message, ErrorTypes.PERMISSION_DENIED);
  } else if (error.code === 'NETWORK_ERROR' || !navigator.onLine) {
    return new DiningError('ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œåé‡è¯•', ErrorTypes.NETWORK_ERROR);
  } else {
    return new DiningError(message, ErrorTypes.SERVER_ERROR);
  }
};
```

### 3.2 é”™è¯¯å¤„ç†ç»„ä»¶

```vue
<!-- components/ErrorHandler.vue -->
<template>
  <div v-if="error" class="error-handler">
    <div class="error-content">
      <div class="error-icon">
        <i :class="errorIcon"></i>
      </div>
      <div class="error-message">
        <h4>{{ errorTitle }}</h4>
        <p>{{ errorMessage }}</p>
      </div>
      <div class="error-actions">
        <button 
          v-if="showRetry"
          @click="handleRetry"
          class="retry-btn"
        >
          é‡è¯•
        </button>
        <button 
          @click="handleDismiss"
          class="dismiss-btn"
        >
          å…³é—­
        </button>
      </div>
    </div>
  </div>
</template>

<script>
import { ErrorTypes } from '@/utils/errorHandler';

export default {
  name: 'ErrorHandler',
  props: {
    error: {
      type: Object,
      default: null
    }
  },
  
  computed: {
    errorIcon() {
      const iconMap = {
        [ErrorTypes.TIME_INVALID]: 'icon-clock',
        [ErrorTypes.ALREADY_CONFIRMED]: 'icon-check-circle',
        [ErrorTypes.ORDER_CANCELLED]: 'icon-close-circle',
        [ErrorTypes.ORDER_NOT_FOUND]: 'icon-question-circle',
        [ErrorTypes.PERMISSION_DENIED]: 'icon-lock',
        [ErrorTypes.NETWORK_ERROR]: 'icon-wifi-off',
        [ErrorTypes.SERVER_ERROR]: 'icon-exclamation-circle'
      };
      return iconMap[this.error?.type] || 'icon-exclamation-circle';
    },
    
    errorTitle() {
      const titleMap = {
        [ErrorTypes.TIME_INVALID]: 'æ—¶é—´é™åˆ¶',
        [ErrorTypes.ALREADY_CONFIRMED]: 'å·²ç¡®è®¤',
        [ErrorTypes.ORDER_CANCELLED]: 'è®¢å•å–æ¶ˆ',
        [ErrorTypes.ORDER_NOT_FOUND]: 'è®¢å•ä¸å­˜åœ¨',
        [ErrorTypes.PERMISSION_DENIED]: 'æƒé™ä¸è¶³',
        [ErrorTypes.NETWORK_ERROR]: 'ç½‘ç»œé”™è¯¯',
        [ErrorTypes.SERVER_ERROR]: 'æœåŠ¡å™¨é”™è¯¯'
      };
      return titleMap[this.error?.type] || 'æ“ä½œå¤±è´¥';
    },
    
    errorMessage() {
      return this.error?.message || 'æœªçŸ¥é”™è¯¯';
    },
    
    showRetry() {
      return [
        ErrorTypes.NETWORK_ERROR,
        ErrorTypes.SERVER_ERROR
      ].includes(this.error?.type);
    }
  },
  
  methods: {
    handleRetry() {
      this.$emit('retry');
    },
    
    handleDismiss() {
      this.$emit('dismiss');
    }
  }
};
</script>
```

## 4. ç”¨æˆ·ä½“éªŒä¼˜åŒ–

### 4.1 åŠ è½½çŠ¶æ€ä¼˜åŒ–

```javascript
// utils/loadingManager.js
class LoadingManager {
  constructor() {
    this.loadingStates = new Map();
  }
  
  setLoading(key, loading = true) {
    this.loadingStates.set(key, loading);
  }
  
  isLoading(key) {
    return this.loadingStates.get(key) || false;
  }
  
  clearLoading(key) {
    this.loadingStates.delete(key);
  }
}

export default new LoadingManager();
```

### 4.2 ç¼“å­˜ç­–ç•¥

```javascript
// utils/cacheManager.js
class CacheManager {
  constructor() {
    this.cache = new Map();
    this.ttl = 5 * 60 * 1000; // 5åˆ†é’Ÿç¼“å­˜
  }
  
  set(key, data, customTtl = null) {
    const ttl = customTtl || this.ttl;
    this.cache.set(key, {
      data,
      expiry: Date.now() + ttl
    });
  }
  
  get(key) {
    const item = this.cache.get(key);
    if (!item) return null;
    
    if (Date.now() > item.expiry) {
      this.cache.delete(key);
      return null;
    }
    
    return item.data;
  }
  
  clear(key) {
    this.cache.delete(key);
  }
  
  clearAll() {
    this.cache.clear();
  }
}

export default new CacheManager();
```

### 4.3 ç¦»çº¿å¤„ç†

```javascript
// utils/offlineManager.js
class OfflineManager {
  constructor() {
    this.pendingRequests = [];
    this.isOnline = navigator.onLine;
    
    window.addEventListener('online', this.handleOnline.bind(this));
    window.addEventListener('offline', this.handleOffline.bind(this));
  }
  
  handleOnline() {
    this.isOnline = true;
    this.processPendingRequests();
  }
  
  handleOffline() {
    this.isOnline = false;
  }
  
  addPendingRequest(request) {
    this.pendingRequests.push(request);
    this.storePendingRequests();
  }
  
  async processPendingRequests() {
    if (!this.isOnline || this.pendingRequests.length === 0) return;
    
    const requests = [...this.pendingRequests];
    this.pendingRequests = [];
    
    for (const request of requests) {
      try {
        await request.execute();
      } catch (error) {
        console.error('é‡è¯•è¯·æ±‚å¤±è´¥:', error);
        this.pendingRequests.push(request);
      }
    }
    
    this.storePendingRequests();
  }
  
  storePendingRequests() {
    localStorage.setItem('pending_requests', JSON.stringify(this.pendingRequests));
  }
}

export default new OfflineManager();
```

## 5. æœ€ä½³å®è·µ

### 5.1 è¯·æ±‚ä¼˜åŒ–

```javascript
// 1. é˜²æŠ–å¤„ç†
import { debounce } from 'lodash';

const debouncedConfirm = debounce(async (orderId) => {
  // ç¡®è®¤å°±é¤é€»è¾‘
}, 300);

// 2. é‡è¯•æœºåˆ¶
async function confirmWithRetry(orderId, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await DiningApi.confirmDining(orderId);
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
}

// 3. å¹¶å‘æ§åˆ¶
class ConcurrencyManager {
  constructor(maxConcurrent = 3) {
    this.maxConcurrent = maxConcurrent;
    this.running = 0;
    this.queue = [];
  }
  
  async execute(task) {
    return new Promise((resolve, reject) => {
      this.queue.push({ task, resolve, reject });
      this.processQueue();
    });
  }
  
  async processQueue() {
    if (this.running >= this.maxConcurrent || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const { task, resolve, reject } = this.queue.shift();
    
    try {
      const result = await task();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.processQueue();
    }
  }
}
```

### 5.2 æ€§èƒ½ç›‘æ§

```javascript
// utils/performanceMonitor.js
class PerformanceMonitor {
  constructor() {
    this.metrics = new Map();
  }
  
  startTiming(key) {
    this.metrics.set(key, { start: Date.now() });
  }
  
  endTiming(key) {
    const metric = this.metrics.get(key);
    if (!metric) return null;
    
    const duration = Date.now() - metric.start;
    metric.duration = duration;
    
    // è®°å½•æ€§èƒ½æ•°æ®
    this.recordMetric(key, duration);
    
    return duration;
  }
  
  recordMetric(key, duration) {
    // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
    if (window.gtag) {
      window.gtag('event', 'api_timing', {
        event_category: 'dining_confirmation',
        event_label: key,
        value: duration
      });
    }
  }
}

export default new PerformanceMonitor();
```

## 6. æµ‹è¯•ç”¨ä¾‹

### 6.1 å•å…ƒæµ‹è¯•

```javascript
// tests/diningConfirmation.test.js
import { mount } from '@vue/test-utils';
import DiningConfirmation from '@/components/DiningConfirmation.vue';
import DiningApi from '@/utils/api';
import TimeUtils from '@/utils/timeUtils';

jest.mock('@/utils/api');
jest.mock('@/utils/timeUtils');

describe('DiningConfirmation', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('should load dining status on mount', async () => {
    const mockData = [
      {
        orderId: 'test-1',
        mealType: 'dinner',
        diningStatus: 'ordered',
        createTime: '2025-09-11T10:00:00Z'
      }
    ];
    
    DiningApi.getDiningStatus.mockResolvedValue({ data: mockData });
    TimeUtils.checkMealTime.mockReturnValue({
      valid: true,
      message: 'å¯ä»¥ç¡®è®¤',
      timeRange: '17:00-20:00'
    });
    
    const wrapper = mount(DiningConfirmation);
    await wrapper.vm.$nextTick();
    
    expect(DiningApi.getDiningStatus).toHaveBeenCalled();
    expect(wrapper.vm.meals).toHaveLength(1);
  });

  test('should handle confirm meal successfully', async () => {
    const mockMeal = {
      orderId: 'test-1',
      mealType: 'dinner',
      diningStatus: 'ordered',
      canConfirm: true
    };
    
    const mockResponse = {
      orderId: 'test-1',
      actualDiningTime: '2025-09-11 18:30:00'
    };
    
    DiningApi.confirmDining.mockResolvedValue(mockResponse);
    
    const wrapper = mount(DiningConfirmation);
    wrapper.vm.meals = [mockMeal];
    
    await wrapper.vm.confirmMeal(mockMeal);
    
    expect(DiningApi.confirmDining).toHaveBeenCalledWith('test-1');
    expect(mockMeal.status).toBe('dined');
  });

  test('should handle time validation error', async () => {
    const mockMeal = {
      orderId: 'test-1',
      mealType: 'dinner',
      diningStatus: 'ordered',
      canConfirm: false
    };
    
    DiningApi.confirmDining.mockRejectedValue(
      new Error('å½“å‰æ—¶é—´ä¸åœ¨æ™šé¤å°±é¤æ—¶é—´å†…')
    );
    
    const wrapper = mount(DiningConfirmation);
    wrapper.vm.meals = [mockMeal];
    
    await wrapper.vm.confirmMeal(mockMeal);
    
    // éªŒè¯é”™è¯¯å¤„ç†é€»è¾‘
    expect(wrapper.vm.error).toBeTruthy();
  });
});
```

### 6.2 é›†æˆæµ‹è¯•

```javascript
// tests/integration/diningConfirmation.integration.test.js
import { createLocalVue, mount } from '@vue/test-utils';
import Vuex from 'vuex';
import DiningConfirmation from '@/components/DiningConfirmation.vue';

const localVue = createLocalVue();
localVue.use(Vuex);

describe('DiningConfirmation Integration', () => {
  let store;
  
  beforeEach(() => {
    store = new Vuex.Store({
      state: {
        user: {
          id: 'test-user',
          role: 'user'
        }
      },
      getters: {
        isAuthenticated: () => true,
        currentUser: (state) => state.user
      }
    });
  });

  test('should work with Vuex store', async () => {
    const wrapper = mount(DiningConfirmation, {
      localVue,
      store
    });
    
    expect(wrapper.vm.$store.getters.isAuthenticated).toBe(true);
  });
});
```

## 7. éƒ¨ç½²é…ç½®

### 7.1 ç¯å¢ƒå˜é‡

```javascript
// .env.development
VUE_APP_API_BASE_URL=http://localhost:3000/api
VUE_APP_ENV=development
VUE_APP_DEBUG=true

// .env.production
VUE_APP_API_BASE_URL=https://api.yourdomain.com/api
VUE_APP_ENV=production
VUE_APP_DEBUG=false
```

### 7.2 æ„å»ºä¼˜åŒ–

```javascript
// vue.config.js
module.exports = {
  configureWebpack: {
    optimization: {
      splitChunks: {
        chunks: 'all',
        cacheGroups: {
          vendor: {
            name: 'chunk-vendors',
            test: /[\\/]node_modules[\\/]/,
            priority: 10,
            chunks: 'initial'
          },
          moment: {
            name: 'chunk-moment',
            test: /[\\/]node_modules[\\/]moment[\\/]/,
            priority: 20
          }
        }
      }
    }
  },
  
  chainWebpack: config => {
    // é¢„åŠ è½½å…³é”®èµ„æº
    config.plugin('preload').tap(options => {
      options[0].include = 'initial';
      return options;
    });
    
    // å‹ç¼©ä¼˜åŒ–
    config.optimization.minimize(true);
  }
};
```

## æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†å®Œæ•´çš„å‰ç«¯ç¡®è®¤å°±é¤è¯·æ±‚å¤„ç†æ–¹æ¡ˆï¼ŒåŒ…æ‹¬ï¼š

1. **åŸºç¡€APIå°è£…**ï¼šç»Ÿä¸€çš„è¯·æ±‚å¤„ç†å’Œé”™è¯¯å¤„ç†
2. **æ—¶åŒºå¤„ç†**ï¼šæ­£ç¡®å¤„ç†åç«¯è¿”å›çš„åŒ—äº¬æ—¶é—´
3. **ç”¨æˆ·ä½“éªŒä¼˜åŒ–**ï¼šåŠ è½½çŠ¶æ€ã€é”™è¯¯æç¤ºã€ç¦»çº¿å¤„ç†
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šç¼“å­˜ã€é˜²æŠ–ã€é‡è¯•æœºåˆ¶
5. **æµ‹è¯•è¦†ç›–**ï¼šå•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
6. **éƒ¨ç½²é…ç½®**ï¼šç¯å¢ƒå˜é‡å’Œæ„å»ºä¼˜åŒ–

é€šè¿‡éµå¾ªè¿™äº›æœ€ä½³å®è·µï¼Œå¯ä»¥ç¡®ä¿å‰ç«¯ç¡®è®¤å°±é¤åŠŸèƒ½ç¨³å®šã€é«˜æ•ˆã€ç”¨æˆ·ä½“éªŒè‰¯å¥½ã€‚
