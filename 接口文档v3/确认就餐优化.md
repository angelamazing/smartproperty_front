# 前端确认就餐请求处理文档

## 概述

本文档详细说明前端如何正确发起确认就餐请求，包括时区处理、错误处理、用户体验优化和最佳实践。

## 1. 确认就餐接口说明

### 1.1 接口信息
- **URL**: `POST /api/dining-confirmation/manual/{orderId}`
- **权限**: 需要用户登录认证
- **功能**: 用户手动确认就餐

### 1.2 请求参数
```javascript
// URL参数
orderId: string  // 订单ID

// 请求体（可选）
{
  "confirmationType": "manual",  // 确认类型，默认为 "manual"
  "remark": "备注信息"           // 可选备注
}
```

### 1.3 响应格式
```javascript
// 成功响应
{
  "success": true,
  "data": {
    "orderId": "订单ID",
    "confirmationType": "manual",
    "actualDiningTime": "2025-09-11 18:30:00",  // 北京时间
    "message": "确认就餐成功"
  },
  "message": "确认就餐成功"
}

// 错误响应
{
  "success": false,
  "message": "错误信息",
  "data": null,
  "code": "400"
}
```

## 2. 前端实现方案

### 2.1 基础请求函数

```javascript
// utils/api.js
import axios from 'axios';
import moment from 'moment-timezone';

class DiningApi {
  constructor() {
    this.baseURL = process.env.VUE_APP_API_BASE_URL || 'http://localhost:3000/api';
    this.axios = axios.create({
      baseURL: this.baseURL,
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    // 添加请求拦截器，自动添加认证token
    this.axios.interceptors.request.use(
      (config) => {
        const token = localStorage.getItem('auth_token');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );
    
    // 添加响应拦截器，统一处理错误
    this.axios.interceptors.response.use(
      (response) => response.data,
      (error) => {
        const message = error.response?.data?.message || '请求失败';
        throw new Error(message);
      }
    );
  }

  /**
   * 确认就餐
   * @param {string} orderId - 订单ID
   * @param {Object} options - 可选参数
   * @returns {Promise} 确认结果
   */
  async confirmDining(orderId, options = {}) {
    try {
      const response = await this.axios.post(
        `/dining-confirmation/manual/${orderId}`,
        {
          confirmationType: 'manual',
          ...options
        }
      );
      return response;
    } catch (error) {
      throw new Error(error.message);
    }
  }

  /**
   * 获取就餐状态
   * @param {string} date - 日期 (YYYY-MM-DD)
   * @returns {Promise} 就餐状态
   */
  async getDiningStatus(date) {
    try {
      const response = await this.axios.get('/dining-confirmation/status', {
        params: { date }
      });
      return response;
    } catch (error) {
      throw new Error(error.message);
    }
  }
}

export default new DiningApi();
```

### 2.2 时间处理工具

```javascript
// utils/timeUtils.js
import moment from 'moment-timezone';

class TimeUtils {
  /**
   * 获取当前北京时间
   * @returns {moment.Moment} 北京时间
   */
  static getBeijingTime() {
    return moment().tz('Asia/Shanghai');
  }

  /**
   * 检查是否在就餐时间内
   * @param {string} mealType - 餐次类型
   * @returns {Object} 检查结果
   */
  static checkMealTime(mealType) {
    const now = this.getBeijingTime();
    const currentHour = now.hour();
    
    const mealTimeRanges = {
      'breakfast': { start: 6, end: 10, name: '早餐' },
      'lunch': { start: 11, end: 14, name: '午餐' },
      'dinner': { start: 17, end: 20, name: '晚餐' }
    };

    const timeRange = mealTimeRanges[mealType];
    if (!timeRange) {
      return { valid: false, message: '无效的餐次类型' };
    }

    const isValid = currentHour >= timeRange.start && currentHour <= timeRange.end;
    
    return {
      valid: isValid,
      message: isValid 
        ? `当前时间可以确认${timeRange.name}就餐`
        : `当前时间不在${timeRange.name}就餐时间内 (${timeRange.start}:00-${timeRange.end}:00)`,
      currentTime: now.format('HH:mm:ss'),
      timeRange: `${timeRange.start}:00-${timeRange.end}:00`
    };
  }

  /**
   * 格式化时间显示
   * @param {string} timeString - 时间字符串
   * @param {string} format - 格式
   * @returns {string} 格式化后的时间
   */
  static formatTime(timeString, format = 'YYYY-MM-DD HH:mm:ss') {
    if (!timeString) return '';
    return moment(timeString).tz('Asia/Shanghai').format(format);
  }

  /**
   * 获取相对时间
   * @param {string} timeString - 时间字符串
   * @returns {string} 相对时间
   */
  static getRelativeTime(timeString) {
    if (!timeString) return '';
    const time = moment(timeString).tz('Asia/Shanghai');
    const now = this.getBeijingTime();
    return time.from(now);
  }
}

export default TimeUtils;
```

### 2.3 Vue组件实现

```vue
<!-- components/DiningConfirmation.vue -->
<template>
  <div class="dining-confirmation">
    <!-- 就餐状态卡片 -->
    <div 
      v-for="meal in meals" 
      :key="meal.type"
      class="meal-card"
      :class="{ 
        'can-confirm': meal.canConfirm,
        'confirmed': meal.status === 'dined',
        'disabled': !meal.canConfirm && meal.status !== 'dined'
      }"
    >
      <div class="meal-header">
        <h3>{{ meal.name }}</h3>
        <span class="status-badge" :class="meal.statusClass">
          {{ meal.statusText }}
        </span>
      </div>
      
      <div class="meal-info">
        <p>报餐时间: {{ meal.orderTime }}</p>
        <p v-if="meal.diningTime">就餐时间: {{ meal.diningTime }}</p>
        <p class="time-range">就餐时间范围: {{ meal.timeRange }}</p>
      </div>
      
      <div class="meal-actions">
        <button 
          v-if="meal.canConfirm"
          @click="confirmMeal(meal)"
          :disabled="confirming"
          class="confirm-btn"
        >
          <i class="icon-check"></i>
          {{ confirming ? '确认中...' : '确认就餐' }}
        </button>
        
        <div v-else-if="meal.status !== 'dined'" class="time-hint">
          <i class="icon-clock"></i>
          {{ meal.timeHint }}
        </div>
        
        <div v-else class="confirmed-info">
          <i class="icon-check-circle"></i>
          已确认就餐
        </div>
      </div>
    </div>
    
    <!-- 加载状态 -->
    <div v-if="loading" class="loading">
      <i class="icon-loading"></i>
      加载中...
    </div>
    
    <!-- 错误提示 -->
    <div v-if="error" class="error-message">
      <i class="icon-error"></i>
      {{ error }}
    </div>
  </div>
</template>

<script>
import DiningApi from '@/utils/api';
import TimeUtils from '@/utils/timeUtils';
import { showToast, showConfirm } from '@/utils/ui';

export default {
  name: 'DiningConfirmation',
  data() {
    return {
      meals: [],
      loading: false,
      confirming: false,
      error: null,
      selectedDate: null
    };
  },
  
  computed: {
    currentDate() {
      return TimeUtils.getBeijingTime().format('YYYY-MM-DD');
    }
  },
  
  async mounted() {
    await this.loadDiningStatus();
  },
  
  methods: {
    /**
     * 加载就餐状态
     */
    async loadDiningStatus() {
      try {
        this.loading = true;
        this.error = null;
        
        const date = this.selectedDate || this.currentDate;
        const response = await DiningApi.getDiningStatus(date);
        
        this.meals = this.processMealsData(response.data);
      } catch (error) {
        this.error = error.message;
        showToast('加载就餐状态失败', 'error');
      } finally {
        this.loading = false;
      }
    },
    
    /**
     * 处理餐次数据
     */
    processMealsData(mealsData) {
      const mealTypes = {
        'breakfast': { name: '早餐', order: 1 },
        'lunch': { name: '午餐', order: 2 },
        'dinner': { name: '晚餐', order: 3 }
      };
      
      return mealsData.map(meal => {
        const mealInfo = mealTypes[meal.mealType];
        const timeCheck = TimeUtils.checkMealTime(meal.mealType);
        
        return {
          ...meal,
          name: mealInfo.name,
          order: mealInfo.order,
          canConfirm: timeCheck.valid && meal.diningStatus === 'ordered',
          timeHint: timeCheck.message,
          timeRange: timeCheck.timeRange,
          statusClass: this.getStatusClass(meal.diningStatus),
          statusText: this.getStatusText(meal.diningStatus),
          orderTime: TimeUtils.getRelativeTime(meal.createTime),
          diningTime: meal.actualDiningTime 
            ? TimeUtils.formatTime(meal.actualDiningTime, 'MM-DD HH:mm')
            : null
        };
      }).sort((a, b) => a.order - b.order);
    },
    
    /**
     * 确认就餐
     */
    async confirmMeal(meal) {
      try {
        // 二次确认
        const confirmed = await showConfirm(
          '确认就餐',
          `确定要确认${meal.name}就餐吗？确认后无法撤销。`
        );
        
        if (!confirmed) return;
        
        this.confirming = true;
        
        const response = await DiningApi.confirmDining(meal.orderId);
        
        // 更新本地状态
        meal.status = 'dined';
        meal.diningTime = TimeUtils.formatTime(response.actualDiningTime, 'MM-DD HH:mm');
        meal.canConfirm = false;
        meal.statusClass = 'confirmed';
        meal.statusText = '已就餐';
        
        showToast('确认就餐成功', 'success');
        
        // 触发父组件更新
        this.$emit('confirmed', meal);
        
      } catch (error) {
        this.handleConfirmError(error, meal);
      } finally {
        this.confirming = false;
      }
    },
    
    /**
     * 处理确认错误
     */
    handleConfirmError(error, meal) {
      console.error('确认就餐失败:', error);
      
      // 根据错误类型显示不同提示
      if (error.message.includes('时间不在')) {
        showToast('当前时间不在就餐时间内，无法确认', 'warning');
      } else if (error.message.includes('已确认')) {
        showToast('该订单已确认就餐', 'info');
        meal.status = 'dined';
        meal.canConfirm = false;
      } else if (error.message.includes('已取消')) {
        showToast('该订单已取消，无法确认', 'error');
        meal.status = 'cancelled';
        meal.canConfirm = false;
      } else {
        showToast(`确认失败: ${error.message}`, 'error');
      }
    },
    
    /**
     * 获取状态样式类
     */
    getStatusClass(status) {
      const statusClasses = {
        'ordered': 'status-ordered',
        'dined': 'status-confirmed',
        'cancelled': 'status-cancelled'
      };
      return statusClasses[status] || 'status-unknown';
    },
    
    /**
     * 获取状态文本
     */
    getStatusText(status) {
      const statusTexts = {
        'ordered': '已报餐',
        'dined': '已就餐',
        'cancelled': '已取消'
      };
      return statusTexts[status] || '未知';
    },
    
    /**
     * 刷新数据
     */
    async refresh() {
      await this.loadDiningStatus();
    }
  }
};
</script>

<style scoped>
.dining-confirmation {
  padding: 20px;
}

.meal-card {
  background: white;
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 16px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;
}

.meal-card.can-confirm {
  border-left: 4px solid #52c41a;
}

.meal-card.confirmed {
  border-left: 4px solid #1890ff;
  background: #f6ffed;
}

.meal-card.disabled {
  opacity: 0.6;
  border-left: 4px solid #d9d9d9;
}

.meal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.meal-header h3 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
}

.status-badge {
  padding: 4px 12px;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 500;
}

.status-ordered {
  background: #fff7e6;
  color: #d46b08;
}

.status-confirmed {
  background: #f6ffed;
  color: #52c41a;
}

.status-cancelled {
  background: #fff2f0;
  color: #ff4d4f;
}

.meal-info {
  margin-bottom: 16px;
}

.meal-info p {
  margin: 4px 0;
  color: #666;
  font-size: 14px;
}

.time-range {
  color: #999 !important;
  font-size: 12px !important;
}

.meal-actions {
  text-align: center;
}

.confirm-btn {
  background: #52c41a;
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 16px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s ease;
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.confirm-btn:hover:not(:disabled) {
  background: #389e0d;
  transform: translateY(-1px);
}

.confirm-btn:disabled {
  background: #d9d9d9;
  cursor: not-allowed;
  transform: none;
}

.time-hint {
  color: #ff7875;
  font-size: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.confirmed-info {
  color: #52c41a;
  font-size: 14px;
  font-weight: 500;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.loading {
  text-align: center;
  padding: 40px;
  color: #666;
}

.error-message {
  background: #fff2f0;
  color: #ff4d4f;
  padding: 16px;
  border-radius: 8px;
  margin: 16px 0;
  display: flex;
  align-items: center;
  gap: 8px;
}

.icon-check::before { content: '✓'; }
.icon-clock::before { content: '🕐'; }
.icon-check-circle::before { content: '✓'; }
.icon-loading::before { content: '⟳'; }
.icon-error::before { content: '⚠'; }
</style>
```

### 2.4 React Hook实现

```javascript
// hooks/useDiningConfirmation.js
import { useState, useEffect, useCallback } from 'react';
import DiningApi from '@/utils/api';
import TimeUtils from '@/utils/timeUtils';

export const useDiningConfirmation = (selectedDate) => {
  const [meals, setMeals] = useState([]);
  const [loading, setLoading] = useState(false);
  const [confirming, setConfirming] = useState(false);
  const [error, setError] = useState(null);

  /**
   * 加载就餐状态
   */
  const loadDiningStatus = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const date = selectedDate || TimeUtils.getBeijingTime().format('YYYY-MM-DD');
      const response = await DiningApi.getDiningStatus(date);
      
      const processedMeals = processMealsData(response.data);
      setMeals(processedMeals);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [selectedDate]);

  /**
   * 处理餐次数据
   */
  const processMealsData = (mealsData) => {
    const mealTypes = {
      'breakfast': { name: '早餐', order: 1 },
      'lunch': { name: '午餐', order: 2 },
      'dinner': { name: '晚餐', order: 3 }
    };
    
    return mealsData.map(meal => {
      const mealInfo = mealTypes[meal.mealType];
      const timeCheck = TimeUtils.checkMealTime(meal.mealType);
      
      return {
        ...meal,
        name: mealInfo.name,
        order: mealInfo.order,
        canConfirm: timeCheck.valid && meal.diningStatus === 'ordered',
        timeHint: timeCheck.message,
        timeRange: timeCheck.timeRange,
        statusClass: getStatusClass(meal.diningStatus),
        statusText: getStatusText(meal.diningStatus),
        orderTime: TimeUtils.getRelativeTime(meal.createTime),
        diningTime: meal.actualDiningTime 
          ? TimeUtils.formatTime(meal.actualDiningTime, 'MM-DD HH:mm')
          : null
      };
    }).sort((a, b) => a.order - b.order);
  };

  /**
   * 确认就餐
   */
  const confirmMeal = useCallback(async (meal) => {
    try {
      setConfirming(true);
      
      const response = await DiningApi.confirmDining(meal.orderId);
      
      // 更新本地状态
      setMeals(prevMeals => 
        prevMeals.map(m => 
          m.orderId === meal.orderId 
            ? {
                ...m,
                status: 'dined',
                diningTime: TimeUtils.formatTime(response.actualDiningTime, 'MM-DD HH:mm'),
                canConfirm: false,
                statusClass: 'confirmed',
                statusText: '已就餐'
              }
            : m
        )
      );
      
      return { success: true, data: response };
    } catch (err) {
      return { success: false, error: err.message };
    } finally {
      setConfirming(false);
    }
  }, []);

  /**
   * 获取状态样式类
   */
  const getStatusClass = (status) => {
    const statusClasses = {
      'ordered': 'status-ordered',
      'dined': 'status-confirmed',
      'cancelled': 'status-cancelled'
    };
    return statusClasses[status] || 'status-unknown';
  };

  /**
   * 获取状态文本
   */
  const getStatusText = (status) => {
    const statusTexts = {
      'ordered': '已报餐',
      'dined': '已就餐',
      'cancelled': '已取消'
    };
    return statusTexts[status] || '未知';
  };

  // 初始化加载
  useEffect(() => {
    loadDiningStatus();
  }, [loadDiningStatus]);

  return {
    meals,
    loading,
    confirming,
    error,
    confirmMeal,
    refresh: loadDiningStatus
  };
};
```

## 3. 错误处理策略

### 3.1 常见错误类型

```javascript
// utils/errorHandler.js
export const ErrorTypes = {
  TIME_INVALID: 'TIME_INVALID',           // 时间不在就餐时间内
  ALREADY_CONFIRMED: 'ALREADY_CONFIRMED', // 已确认就餐
  ORDER_CANCELLED: 'ORDER_CANCELLED',     // 订单已取消
  ORDER_NOT_FOUND: 'ORDER_NOT_FOUND',     // 订单不存在
  PERMISSION_DENIED: 'PERMISSION_DENIED', // 权限不足
  NETWORK_ERROR: 'NETWORK_ERROR',         // 网络错误
  SERVER_ERROR: 'SERVER_ERROR'            // 服务器错误
};

export class DiningError extends Error {
  constructor(message, type, details = null) {
    super(message);
    this.name = 'DiningError';
    this.type = type;
    this.details = details;
  }
}

export const handleDiningError = (error) => {
  const message = error.message || '未知错误';
  
  if (message.includes('时间不在')) {
    return new DiningError(message, ErrorTypes.TIME_INVALID);
  } else if (message.includes('已确认')) {
    return new DiningError(message, ErrorTypes.ALREADY_CONFIRMED);
  } else if (message.includes('已取消')) {
    return new DiningError(message, ErrorTypes.ORDER_CANCELLED);
  } else if (message.includes('不存在')) {
    return new DiningError(message, ErrorTypes.ORDER_NOT_FOUND);
  } else if (message.includes('权限')) {
    return new DiningError(message, ErrorTypes.PERMISSION_DENIED);
  } else if (error.code === 'NETWORK_ERROR' || !navigator.onLine) {
    return new DiningError('网络连接失败，请检查网络后重试', ErrorTypes.NETWORK_ERROR);
  } else {
    return new DiningError(message, ErrorTypes.SERVER_ERROR);
  }
};
```

### 3.2 错误处理组件

```vue
<!-- components/ErrorHandler.vue -->
<template>
  <div v-if="error" class="error-handler">
    <div class="error-content">
      <div class="error-icon">
        <i :class="errorIcon"></i>
      </div>
      <div class="error-message">
        <h4>{{ errorTitle }}</h4>
        <p>{{ errorMessage }}</p>
      </div>
      <div class="error-actions">
        <button 
          v-if="showRetry"
          @click="handleRetry"
          class="retry-btn"
        >
          重试
        </button>
        <button 
          @click="handleDismiss"
          class="dismiss-btn"
        >
          关闭
        </button>
      </div>
    </div>
  </div>
</template>

<script>
import { ErrorTypes } from '@/utils/errorHandler';

export default {
  name: 'ErrorHandler',
  props: {
    error: {
      type: Object,
      default: null
    }
  },
  
  computed: {
    errorIcon() {
      const iconMap = {
        [ErrorTypes.TIME_INVALID]: 'icon-clock',
        [ErrorTypes.ALREADY_CONFIRMED]: 'icon-check-circle',
        [ErrorTypes.ORDER_CANCELLED]: 'icon-close-circle',
        [ErrorTypes.ORDER_NOT_FOUND]: 'icon-question-circle',
        [ErrorTypes.PERMISSION_DENIED]: 'icon-lock',
        [ErrorTypes.NETWORK_ERROR]: 'icon-wifi-off',
        [ErrorTypes.SERVER_ERROR]: 'icon-exclamation-circle'
      };
      return iconMap[this.error?.type] || 'icon-exclamation-circle';
    },
    
    errorTitle() {
      const titleMap = {
        [ErrorTypes.TIME_INVALID]: '时间限制',
        [ErrorTypes.ALREADY_CONFIRMED]: '已确认',
        [ErrorTypes.ORDER_CANCELLED]: '订单取消',
        [ErrorTypes.ORDER_NOT_FOUND]: '订单不存在',
        [ErrorTypes.PERMISSION_DENIED]: '权限不足',
        [ErrorTypes.NETWORK_ERROR]: '网络错误',
        [ErrorTypes.SERVER_ERROR]: '服务器错误'
      };
      return titleMap[this.error?.type] || '操作失败';
    },
    
    errorMessage() {
      return this.error?.message || '未知错误';
    },
    
    showRetry() {
      return [
        ErrorTypes.NETWORK_ERROR,
        ErrorTypes.SERVER_ERROR
      ].includes(this.error?.type);
    }
  },
  
  methods: {
    handleRetry() {
      this.$emit('retry');
    },
    
    handleDismiss() {
      this.$emit('dismiss');
    }
  }
};
</script>
```

## 4. 用户体验优化

### 4.1 加载状态优化

```javascript
// utils/loadingManager.js
class LoadingManager {
  constructor() {
    this.loadingStates = new Map();
  }
  
  setLoading(key, loading = true) {
    this.loadingStates.set(key, loading);
  }
  
  isLoading(key) {
    return this.loadingStates.get(key) || false;
  }
  
  clearLoading(key) {
    this.loadingStates.delete(key);
  }
}

export default new LoadingManager();
```

### 4.2 缓存策略

```javascript
// utils/cacheManager.js
class CacheManager {
  constructor() {
    this.cache = new Map();
    this.ttl = 5 * 60 * 1000; // 5分钟缓存
  }
  
  set(key, data, customTtl = null) {
    const ttl = customTtl || this.ttl;
    this.cache.set(key, {
      data,
      expiry: Date.now() + ttl
    });
  }
  
  get(key) {
    const item = this.cache.get(key);
    if (!item) return null;
    
    if (Date.now() > item.expiry) {
      this.cache.delete(key);
      return null;
    }
    
    return item.data;
  }
  
  clear(key) {
    this.cache.delete(key);
  }
  
  clearAll() {
    this.cache.clear();
  }
}

export default new CacheManager();
```

### 4.3 离线处理

```javascript
// utils/offlineManager.js
class OfflineManager {
  constructor() {
    this.pendingRequests = [];
    this.isOnline = navigator.onLine;
    
    window.addEventListener('online', this.handleOnline.bind(this));
    window.addEventListener('offline', this.handleOffline.bind(this));
  }
  
  handleOnline() {
    this.isOnline = true;
    this.processPendingRequests();
  }
  
  handleOffline() {
    this.isOnline = false;
  }
  
  addPendingRequest(request) {
    this.pendingRequests.push(request);
    this.storePendingRequests();
  }
  
  async processPendingRequests() {
    if (!this.isOnline || this.pendingRequests.length === 0) return;
    
    const requests = [...this.pendingRequests];
    this.pendingRequests = [];
    
    for (const request of requests) {
      try {
        await request.execute();
      } catch (error) {
        console.error('重试请求失败:', error);
        this.pendingRequests.push(request);
      }
    }
    
    this.storePendingRequests();
  }
  
  storePendingRequests() {
    localStorage.setItem('pending_requests', JSON.stringify(this.pendingRequests));
  }
}

export default new OfflineManager();
```

## 5. 最佳实践

### 5.1 请求优化

```javascript
// 1. 防抖处理
import { debounce } from 'lodash';

const debouncedConfirm = debounce(async (orderId) => {
  // 确认就餐逻辑
}, 300);

// 2. 重试机制
async function confirmWithRetry(orderId, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await DiningApi.confirmDining(orderId);
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
}

// 3. 并发控制
class ConcurrencyManager {
  constructor(maxConcurrent = 3) {
    this.maxConcurrent = maxConcurrent;
    this.running = 0;
    this.queue = [];
  }
  
  async execute(task) {
    return new Promise((resolve, reject) => {
      this.queue.push({ task, resolve, reject });
      this.processQueue();
    });
  }
  
  async processQueue() {
    if (this.running >= this.maxConcurrent || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const { task, resolve, reject } = this.queue.shift();
    
    try {
      const result = await task();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.processQueue();
    }
  }
}
```

### 5.2 性能监控

```javascript
// utils/performanceMonitor.js
class PerformanceMonitor {
  constructor() {
    this.metrics = new Map();
  }
  
  startTiming(key) {
    this.metrics.set(key, { start: Date.now() });
  }
  
  endTiming(key) {
    const metric = this.metrics.get(key);
    if (!metric) return null;
    
    const duration = Date.now() - metric.start;
    metric.duration = duration;
    
    // 记录性能数据
    this.recordMetric(key, duration);
    
    return duration;
  }
  
  recordMetric(key, duration) {
    // 发送到监控系统
    if (window.gtag) {
      window.gtag('event', 'api_timing', {
        event_category: 'dining_confirmation',
        event_label: key,
        value: duration
      });
    }
  }
}

export default new PerformanceMonitor();
```

## 6. 测试用例

### 6.1 单元测试

```javascript
// tests/diningConfirmation.test.js
import { mount } from '@vue/test-utils';
import DiningConfirmation from '@/components/DiningConfirmation.vue';
import DiningApi from '@/utils/api';
import TimeUtils from '@/utils/timeUtils';

jest.mock('@/utils/api');
jest.mock('@/utils/timeUtils');

describe('DiningConfirmation', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('should load dining status on mount', async () => {
    const mockData = [
      {
        orderId: 'test-1',
        mealType: 'dinner',
        diningStatus: 'ordered',
        createTime: '2025-09-11T10:00:00Z'
      }
    ];
    
    DiningApi.getDiningStatus.mockResolvedValue({ data: mockData });
    TimeUtils.checkMealTime.mockReturnValue({
      valid: true,
      message: '可以确认',
      timeRange: '17:00-20:00'
    });
    
    const wrapper = mount(DiningConfirmation);
    await wrapper.vm.$nextTick();
    
    expect(DiningApi.getDiningStatus).toHaveBeenCalled();
    expect(wrapper.vm.meals).toHaveLength(1);
  });

  test('should handle confirm meal successfully', async () => {
    const mockMeal = {
      orderId: 'test-1',
      mealType: 'dinner',
      diningStatus: 'ordered',
      canConfirm: true
    };
    
    const mockResponse = {
      orderId: 'test-1',
      actualDiningTime: '2025-09-11 18:30:00'
    };
    
    DiningApi.confirmDining.mockResolvedValue(mockResponse);
    
    const wrapper = mount(DiningConfirmation);
    wrapper.vm.meals = [mockMeal];
    
    await wrapper.vm.confirmMeal(mockMeal);
    
    expect(DiningApi.confirmDining).toHaveBeenCalledWith('test-1');
    expect(mockMeal.status).toBe('dined');
  });

  test('should handle time validation error', async () => {
    const mockMeal = {
      orderId: 'test-1',
      mealType: 'dinner',
      diningStatus: 'ordered',
      canConfirm: false
    };
    
    DiningApi.confirmDining.mockRejectedValue(
      new Error('当前时间不在晚餐就餐时间内')
    );
    
    const wrapper = mount(DiningConfirmation);
    wrapper.vm.meals = [mockMeal];
    
    await wrapper.vm.confirmMeal(mockMeal);
    
    // 验证错误处理逻辑
    expect(wrapper.vm.error).toBeTruthy();
  });
});
```

### 6.2 集成测试

```javascript
// tests/integration/diningConfirmation.integration.test.js
import { createLocalVue, mount } from '@vue/test-utils';
import Vuex from 'vuex';
import DiningConfirmation from '@/components/DiningConfirmation.vue';

const localVue = createLocalVue();
localVue.use(Vuex);

describe('DiningConfirmation Integration', () => {
  let store;
  
  beforeEach(() => {
    store = new Vuex.Store({
      state: {
        user: {
          id: 'test-user',
          role: 'user'
        }
      },
      getters: {
        isAuthenticated: () => true,
        currentUser: (state) => state.user
      }
    });
  });

  test('should work with Vuex store', async () => {
    const wrapper = mount(DiningConfirmation, {
      localVue,
      store
    });
    
    expect(wrapper.vm.$store.getters.isAuthenticated).toBe(true);
  });
});
```

## 7. 部署配置

### 7.1 环境变量

```javascript
// .env.development
VUE_APP_API_BASE_URL=http://localhost:3000/api
VUE_APP_ENV=development
VUE_APP_DEBUG=true

// .env.production
VUE_APP_API_BASE_URL=https://api.yourdomain.com/api
VUE_APP_ENV=production
VUE_APP_DEBUG=false
```

### 7.2 构建优化

```javascript
// vue.config.js
module.exports = {
  configureWebpack: {
    optimization: {
      splitChunks: {
        chunks: 'all',
        cacheGroups: {
          vendor: {
            name: 'chunk-vendors',
            test: /[\\/]node_modules[\\/]/,
            priority: 10,
            chunks: 'initial'
          },
          moment: {
            name: 'chunk-moment',
            test: /[\\/]node_modules[\\/]moment[\\/]/,
            priority: 20
          }
        }
      }
    }
  },
  
  chainWebpack: config => {
    // 预加载关键资源
    config.plugin('preload').tap(options => {
      options[0].include = 'initial';
      return options;
    });
    
    // 压缩优化
    config.optimization.minimize(true);
  }
};
```

## 总结

本文档提供了完整的前端确认就餐请求处理方案，包括：

1. **基础API封装**：统一的请求处理和错误处理
2. **时区处理**：正确处理后端返回的北京时间
3. **用户体验优化**：加载状态、错误提示、离线处理
4. **性能优化**：缓存、防抖、重试机制
5. **测试覆盖**：单元测试和集成测试
6. **部署配置**：环境变量和构建优化

通过遵循这些最佳实践，可以确保前端确认就餐功能稳定、高效、用户体验良好。
